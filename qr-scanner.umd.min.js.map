{"version":3,"file":"qr-scanner.umd.min.js","sources":["src/qr-scanner.ts"],"sourcesContent":["class QrScanner {\n    static readonly DEFAULT_CANVAS_SIZE = 400;\n    static readonly NO_QR_CODE_FOUND = 'No QR code found';\n    private static _disableBarcodeDetector = true;\n    private static _workerMessageId = 0;\n\n    /** @deprecated */\n    static set WORKER_PATH(workerPath: string) {\n        console.warn('Setting QrScanner.WORKER_PATH is not required and not supported anymore. '\n            + 'Have a look at the README for new setup instructions.');\n    }\n\n    static async hasCamera(): Promise<boolean> {\n        try {\n            return !!(await QrScanner.listCameras(false)).length;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    static async listCameras(requestLabels = false): Promise<Array<QrScanner.Camera>> {\n        if (!navigator.mediaDevices) return [];\n\n        const enumerateCameras = async (): Promise<Array<MediaDeviceInfo>> =>\n            (await navigator.mediaDevices.enumerateDevices()).filter((device) => device.kind === 'videoinput');\n\n        // Note that enumerateDevices can always be called and does not prompt the user for permission.\n        // However, enumerateDevices only includes device labels if served via https and an active media stream exists\n        // or permission to access the camera was given. Therefore, if we're not getting labels but labels are requested\n        // ask for camera permission by opening a stream.\n        let openedStream: MediaStream | undefined;\n        try {\n            if (requestLabels && (await enumerateCameras()).every((camera) => !camera.label)) {\n                openedStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });\n            }\n        } catch (e) {\n            // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in use\n            // and some browsers disallow a second stream.\n        }\n\n        try {\n            return (await enumerateCameras()).map((camera, i) => ({\n                id: camera.deviceId,\n                label: camera.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),\n            }));\n        } finally {\n            // close the stream we just opened for getting camera access for listing the device labels\n            if (openedStream) {\n                console.warn('Call listCameras after successfully starting a QR scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(openedStream);\n            }\n        }\n    }\n\n    readonly $video: HTMLVideoElement;\n    readonly $canvas: HTMLCanvasElement;\n    readonly $overlay?: HTMLDivElement;\n    private readonly $codeOutlineHighlight?: SVGSVGElement;\n    private readonly _onDecode?: (result: QrScanner.ScanResult) => void;\n    private readonly _legacyOnDecode?: (result: string) => void;\n    private readonly _legacyCanvasSize: number = QrScanner.DEFAULT_CANVAS_SIZE;\n    private _preferredCamera: QrScanner.FacingMode | QrScanner.DeviceId = 'environment';\n    private readonly _maxScansPerSecond: number = 25;\n    private _lastScanTimestamp: number = -1;\n    private _scanRegion: QrScanner.ScanRegion;\n    private _codeOutlineHighlightRemovalTimeout?: number;\n    private _qrEngine: Worker\n    private _active: boolean = false;\n    private _paused: boolean = false;\n    private _flashOn: boolean = false;\n    private _destroyed: boolean = false;\n\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: QrScanner.ScanResult) => void,\n        options: {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: (result: string) => void,\n        onDecodeError?: (error: Error | string) => void,\n        canvasSize?: number,\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    );\n    /** @deprecated */\n    constructor(video: HTMLVideoElement, onDecode: (result: string) => void, canvasSize?: number);\n    constructor(\n        video: HTMLVideoElement,\n        onDecode: ((result: QrScanner.ScanResult) => void) | ((result: string) => void),\n        canvasSizeOrOnDecodeErrorOrOptions?: number | ((error: Error | string) => void) | {\n            onDecodeError?: (error: Error | string) => void,\n            calculateScanRegion?: (video: HTMLVideoElement) => QrScanner.ScanRegion,\n            preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n            maxScansPerSecond?: number;\n            highlightScanRegion?: boolean,\n            highlightCodeOutline?: boolean,\n            overlay?: HTMLDivElement,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n        canvasSizeOrCalculateScanRegion?: number | ((video: HTMLVideoElement) => QrScanner.ScanRegion),\n        preferredCamera?: QrScanner.FacingMode | QrScanner.DeviceId,\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n\n        if (canvasSizeOrOnDecodeErrorOrOptions && typeof canvasSizeOrOnDecodeErrorOrOptions === 'object') {\n            // we got an options object using the new api\n            this._onDecode = onDecode as QrScanner['_onDecode'];\n        } else {\n            if (canvasSizeOrOnDecodeErrorOrOptions || canvasSizeOrCalculateScanRegion || preferredCamera) {\n                console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                    + 'the future');\n            } else {\n                // Only video and onDecode were specified and we can't distinguish between new or old api usage. For\n                // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n                // optional in the parameter list above to make clear that ScanResult instead of string is only passed\n                // if an options object was provided. However, in the future once legacy support is removed, the options\n                // object should become optional.\n                console.warn('Note that the type of the scan result passed to onDecode will change in the future. '\n                    + 'To already switch to the new api today, you can pass returnDetailedScanResult: true.');\n            }\n            this._legacyOnDecode = onDecode as QrScanner['_legacyOnDecode'];\n        }\n\n        const options = typeof canvasSizeOrOnDecodeErrorOrOptions === 'object'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : {};\n        this._onDecodeError = options.onDecodeError || (typeof canvasSizeOrOnDecodeErrorOrOptions === 'function'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : this._onDecodeError);\n        this._calculateScanRegion = options.calculateScanRegion || (typeof canvasSizeOrCalculateScanRegion==='function'\n            ? canvasSizeOrCalculateScanRegion\n            : this._calculateScanRegion);\n        this._preferredCamera = options.preferredCamera || preferredCamera || this._preferredCamera;\n        this._legacyCanvasSize = typeof canvasSizeOrOnDecodeErrorOrOptions === 'number'\n            ? canvasSizeOrOnDecodeErrorOrOptions\n            : typeof canvasSizeOrCalculateScanRegion === 'number'\n                ? canvasSizeOrCalculateScanRegion\n                : this._legacyCanvasSize;\n        this._maxScansPerSecond = options.maxScansPerSecond || this._maxScansPerSecond;\n\n        this._onPlay = this._onPlay.bind(this);\n        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n        this._updateOverlay = this._updateOverlay.bind(this);\n\n        // @ts-ignore\n        video.disablePictureInPicture = true;\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        // @ts-ignore\n        video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        video.muted = true;\n\n        // Avoid Safari stopping the video stream on a hidden video.\n        // See https://github.com/cozmo/jsQR/issues/185\n        let shouldHideVideo = false;\n        if (video.hidden) {\n            video.hidden = false;\n            shouldHideVideo = true;\n        }\n        if (!document.body.contains(video)) {\n            document.body.appendChild(video);\n            shouldHideVideo = true;\n        }\n        const videoContainer = video.parentElement!;\n\n        if (options.highlightScanRegion || options.highlightCodeOutline) {\n            const gotExternalOverlay = !!options.overlay;\n            this.$overlay = options.overlay || document.createElement('div');\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.position = 'absolute';\n            overlayStyle.display = 'none';\n            overlayStyle.pointerEvents = 'none';\n            this.$overlay.classList.add('scan-region-highlight');\n            if (!gotExternalOverlay && options.highlightScanRegion) {\n                // default style; can be overwritten via css, e.g. by changing the svg's stroke color, hiding the\n                // .scan-region-highlight-svg, setting a border, outline, background, etc.\n                this.$overlay.innerHTML = '<svg class=\"scan-region-highlight-svg\" viewBox=\"0 0 238 238\" '\n                    + 'preserveAspectRatio=\"none\" style=\"position:absolute;width:100%;height:100%;left:0;top:0;'\n                    + 'fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round\">'\n                    + '<path d=\"M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 '\n                    + '0H10a8 8 0 0 1-8-8v-21\"/></svg>';\n                try {\n                    this.$overlay.firstElementChild!.animate({ transform: ['scale(.98)', 'scale(1.01)'] }, {\n                        duration: 400,\n                        iterations: Infinity,\n                        direction: 'alternate',\n                        easing: 'ease-in-out',\n                    });\n                } catch (e) {}\n                videoContainer.insertBefore(this.$overlay, this.$video.nextSibling);\n            }\n            if (options.highlightCodeOutline) {\n                // default style; can be overwritten via css\n                this.$overlay.insertAdjacentHTML(\n                    'beforeend',\n                    '<svg class=\"code-outline-highlight\" preserveAspectRatio=\"none\" style=\"display:none;width:100%;'\n                        + 'height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;'\n                        + 'stroke-linecap:round;stroke-linejoin:round\"><polygon/></svg>',\n                );\n                this.$codeOutlineHighlight = this.$overlay.lastElementChild as SVGSVGElement;\n            }\n        }\n        this._scanRegion = this._calculateScanRegion(video);\n\n        requestAnimationFrame(() => {\n            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.\n            const videoStyle = window.getComputedStyle(video);\n            if (videoStyle.display === 'none') {\n                video.style.setProperty('display', 'block', 'important');\n                shouldHideVideo = true;\n            }\n            if (videoStyle.visibility !== 'visible') {\n                video.style.setProperty('visibility', 'visible', 'important');\n                shouldHideVideo = true;\n            }\n            if (shouldHideVideo) {\n                // Hide the video in a way that doesn't cause Safari to stop the playback.\n                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');\n                video.style.opacity = '0';\n                video.style.width = '0';\n                video.style.height = '0';\n                if (this.$overlay && this.$overlay.parentElement) {\n                    this.$overlay.parentElement.removeChild(this.$overlay);\n                }\n                // @ts-ignore\n                delete this.$overlay!;\n                // @ts-ignore\n                delete this.$codeOutlineHighlight!;\n            }\n\n            if (this.$overlay) {\n                this._updateOverlay();\n            }\n        });\n\n        video.addEventListener('play', this._onPlay);\n        video.addEventListener('loadedmetadata', this._onLoadedMetaData);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n        window.addEventListener('resize', this._updateOverlay);\n\n        this._qrEngine = QrScanner.createQrEngine();\n    }\n\n    async hasFlash(): Promise<boolean> {\n        let stream: MediaStream | undefined;\n        try {\n            if (this.$video.srcObject) {\n                if (!(this.$video.srcObject instanceof MediaStream)) return false; // srcObject is not a camera stream\n                stream = this.$video.srcObject;\n            } else {\n                stream = (await this._getCameraStream()).stream;\n            }\n            return 'torch' in stream.getVideoTracks()[0].getSettings();\n        } catch (e) {\n            return false;\n        } finally {\n            // close the stream we just opened for detecting whether it supports flash\n            if (stream && stream !== this.$video.srcObject) {\n                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '\n                    + 'a temporary video stream');\n                QrScanner._stopVideoStream(stream);\n            }\n        }\n    }\n\n    isFlashOn(): boolean {\n        return this._flashOn;\n    }\n\n    async toggleFlash(): Promise<void> {\n        if (this._flashOn) {\n            await this.turnFlashOff();\n        } else {\n            await this.turnFlashOn();\n        }\n    }\n\n    async turnFlashOn(): Promise<void> {\n        if (this._flashOn || this._destroyed) return;\n        this._flashOn = true;\n        if (!this._active || this._paused) return; // flash will be turned on later on .start()\n        try {\n            if (!await this.hasFlash()) throw 'No flash available';\n            // Note that the video track is guaranteed to exist and to be a MediaStream due to the check in hasFlash\n            await (this.$video.srcObject as MediaStream).getVideoTracks()[0].applyConstraints({\n                // @ts-ignore: constraint 'torch' is unknown to ts\n                advanced: [{ torch: true }],\n            });\n        } catch (e) {\n            this._flashOn = false;\n            throw e;\n        }\n    }\n\n    async turnFlashOff(): Promise<void> {\n        if (!this._flashOn) return;\n        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays\n        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,\n        // we have to stop the stream to turn the flashlight off.\n        this._flashOn = false;\n        await this._restartVideoStream();\n    }\n\n    destroy(): void {\n        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n        window.removeEventListener('resize', this._updateOverlay);\n\n        this._destroyed = true;\n        this._flashOn = false;\n        this.stop(); // sets this._paused = true and this._active = false\n        QrScanner._postWorkerMessage(this._qrEngine, 'close');\n    }\n\n    async start(): Promise<void> {\n        if (this._destroyed) throw new Error('The QR scanner can not be started as it had been destroyed.');\n        if (this._active && !this._paused) return;\n\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n\n        this._active = true;\n        if (document.hidden) return; // camera will be started as soon as tab is in foreground\n        this._paused = false;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            await this.$video.play();\n            return;\n        }\n\n        try {\n            const { stream, facingMode } = await this._getCameraStream();\n            if (!this._active || this._paused) {\n                // was stopped in the meantime\n                QrScanner._stopVideoStream(stream);\n                return;\n            }\n            this._setVideoMirror(facingMode);\n            this.$video.srcObject = stream;\n            await this.$video.play();\n\n            // Restart the flash if it was previously on\n            if (this._flashOn) {\n                this._flashOn = false; // force turnFlashOn to restart the flash\n                this.turnFlashOn().catch(() => {});\n            }\n        } catch (e) {\n            if (this._paused) return;\n            this._active = false;\n            throw e;\n        }\n    }\n\n    stop(): void {\n        this.pause();\n        this._active = false;\n    }\n\n    async pause(stopStreamImmediately = false): Promise<boolean> {\n        this._paused = true;\n        if (!this._active) return true;\n        this.$video.pause();\n\n        if (this.$overlay) {\n            this.$overlay.style.display = 'none';\n        }\n\n        const stopStream = () => {\n            if (this.$video.srcObject instanceof MediaStream) {\n                // revoke srcObject only if it's a stream which was likely set by us\n                QrScanner._stopVideoStream(this.$video.srcObject);\n                this.$video.srcObject = null;\n            }\n        };\n\n        if (stopStreamImmediately) {\n            stopStream();\n            return true;\n        }\n\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        if (!this._paused) return false;\n        stopStream();\n        return true;\n    }\n\n    async setCamera(facingModeOrDeviceId: QrScanner.FacingMode | QrScanner.DeviceId): Promise<void> {\n        if (facingModeOrDeviceId === this._preferredCamera) return;\n        this._preferredCamera = facingModeOrDeviceId;\n        // Restart the scanner with the new camera which will also update the video mirror and the scan region.\n        await this._restartVideoStream();\n    }\n\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        options: {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        },\n    ): Promise<QrScanner.ScanResult>;\n    /** @deprecated */\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegion?: QrScanner.ScanRegion | null,\n        qrEngine?: Worker | BarcodeDetector | Promise<Worker | BarcodeDetector> | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing?: boolean,\n        alsoTryWithoutScanRegion?: boolean,\n    ): Promise<string>;\n    static async scanImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n        scanRegionOrOptions?: QrScanner.ScanRegion | {\n            scanRegion?: QrScanner.ScanRegion | null,\n            qrEngine?: Worker | null,\n            canvas?: HTMLCanvasElement | null,\n            disallowCanvasResizing?: boolean,\n            alsoTryWithoutScanRegion?: boolean,\n            /** just a temporary flag until we switch entirely to the new api */\n            returnDetailedScanResult?: true,\n        } | null,\n        qrEngine?: Worker | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing: boolean = false,\n        alsoTryWithoutScanRegion: boolean = false,\n    ): Promise<string | QrScanner.ScanResult> {\n        let scanRegion: QrScanner.ScanRegion | null | undefined;\n        let returnDetailedScanResult = false;\n        if (scanRegionOrOptions && (\n            'scanRegion' in scanRegionOrOptions\n            || 'qrEngine' in scanRegionOrOptions\n            || 'canvas' in scanRegionOrOptions\n            || 'disallowCanvasResizing' in scanRegionOrOptions\n            || 'alsoTryWithoutScanRegion' in scanRegionOrOptions\n            || 'returnDetailedScanResult' in scanRegionOrOptions\n        )) {\n            // we got an options object using the new api\n            scanRegion = scanRegionOrOptions.scanRegion;\n            qrEngine = scanRegionOrOptions.qrEngine;\n            canvas = scanRegionOrOptions.canvas;\n            disallowCanvasResizing = scanRegionOrOptions.disallowCanvasResizing || false;\n            alsoTryWithoutScanRegion = scanRegionOrOptions.alsoTryWithoutScanRegion || false;\n            returnDetailedScanResult = true;\n        } else if (scanRegionOrOptions || qrEngine || canvas || disallowCanvasResizing || alsoTryWithoutScanRegion) {\n            console.warn('You\\'re using a deprecated api for scanImage which will be removed in the future.');\n        } else {\n            // Only imageOrFileOrBlobOrUrl was specified and we can't distinguish between new or old api usage. For\n            // backwards compatibility we have to assume the old api for now. The options object is marked as non-\n            // optional in the parameter list above to make clear that ScanResult instead of string is only returned if\n            // an options object was provided. However, in the future once legacy support is removed, the options object\n            // should become optional.\n            console.warn('Note that the return type of scanImage will change in the future. To already switch to the '\n                + 'new api today, you can pass returnDetailedScanResult: true.');\n        }\n\n        const gotExternalEngine = !!qrEngine;\n\n        try {\n            let image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n                | SVGImageElement;\n            let canvasContext: CanvasRenderingContext2D;\n\n            if (!qrEngine) {\n                qrEngine = QrScanner.createQrEngine();\n            }\n\n            image = await QrScanner._loadImage(imageOrFileOrBlobOrUrl);\n            [canvas, canvasContext] = QrScanner._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);\n            let detailedScanResult: QrScanner.ScanResult;\n\n            // const qrEngine = qrEngine; // for ts to know that it's still a worker later in the event listeners\n            if (!gotExternalEngine) {\n                // Enable scanning of inverted color qr codes.\n                QrScanner._postWorkerMessageSync(qrEngine, 'inversionMode', 'both');\n            }\n            detailedScanResult = await new Promise((resolve, reject) => {\n                let timeout: number;\n                let onMessage: (event: MessageEvent) => void;\n                let onError: (error: ErrorEvent | string) => void;\n                let expectedResponseId = -1;\n                onMessage = (event: MessageEvent) => {\n                    if (event.data.id !== expectedResponseId) {\n                        return;\n                    }\n                    qrEngine!.removeEventListener('message', onMessage);\n                    qrEngine!.removeEventListener('error', onError);\n                    clearTimeout(timeout);\n                    if (event.data.data !== null) {\n                        const res: QrScanner.ScanResult = {\n                            data: event.data.data,\n                            cornerPointsOrig: event.data.cornerPoints,\n                            cornerPoints: QrScanner._convertPoints(event.data.cornerPoints, scanRegion),\n                        };\n                        if (imageOrFileOrBlobOrUrl instanceof HTMLVideoElement) {\n                            canvas!.toBlob((blob) => {\n                                if (blob) {\n                                    resolve({...res, scannedFrame: blob})\n                                } else {\n                                    resolve(res);\n                                }\n                            })\n                        } else {\n                            resolve(res);\n                        }\n                    } else {\n                        reject(QrScanner.NO_QR_CODE_FOUND);\n                    }\n                };\n                onError = (error: ErrorEvent | string) => {\n                    qrEngine!.removeEventListener('message', onMessage);\n                    qrEngine!.removeEventListener('error', onError);\n                    clearTimeout(timeout);\n                    const errorMessage = !error ? 'Unknown Error' : ((error as ErrorEvent).message || error);\n                    reject('Scanner error: ' + errorMessage);\n                };\n                qrEngine!.addEventListener('message', onMessage);\n                qrEngine!.addEventListener('error', onError);\n                timeout = setTimeout(() => onError('timeout'), 10000);\n                const imageData = canvasContext.getImageData(0, 0, canvas!.width, canvas!.height);\n                expectedResponseId = QrScanner._postWorkerMessageSync(\n                    qrEngine!,\n                    'decode',\n                    imageData,\n                    [imageData.data.buffer],\n                );\n              });\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } catch (e) {\n            if (!scanRegion || !alsoTryWithoutScanRegion) throw e;\n            const detailedScanResult = await QrScanner.scanImage(\n                imageOrFileOrBlobOrUrl,\n                { qrEngine, canvas, disallowCanvasResizing },\n            );\n            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;\n        } finally {\n            if (!gotExternalEngine) {\n                console.log(\"not got external engine: \", qrEngine)\n                QrScanner._postWorkerMessage(qrEngine!, 'close');\n            }\n        }\n    }\n\n    setGrayscaleWeights(red: number, green: number, blue: number, useIntegerApproximation: boolean = true): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations work also well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEngine,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode: QrScanner.InversionMode): void {\n        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native\n        // implementations scan normal and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEngine, 'inversionMode', inversionMode);\n    }\n\n    static createQrEngine(): Worker;\n    /** @deprecated */\n    static createQrEngine(workerPath: string): Worker;\n    static createQrEngine(workerPath?: string): Worker {\n        if (workerPath) {\n            console.warn('Specifying a worker path is not required and not supported anymore.');\n        }\n\n        return new Worker(new URL('./qr-scanner-worker.min.js', import.meta.url), {\n            type: 'module'\n        });\n    }\n\n    private _onPlay(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n        if (this.$overlay) {\n            this.$overlay.style.display = '';\n        }\n        this._scanFrame();\n    }\n\n    private _onLoadedMetaData(): void {\n        this._scanRegion = this._calculateScanRegion(this.$video);\n        this._updateOverlay();\n    }\n\n    private _onVisibilityChange(): void {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    private _calculateScanRegion(video: HTMLVideoElement): QrScanner.ScanRegion {\n        // Default scan region calculation. Note that this can be overwritten in the constructor.\n        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);\n        const scanRegionSize = Math.round(2 / 3 * smallestDimension);\n        return {\n            x: Math.round((video.videoWidth - scanRegionSize) / 2),\n            y: Math.round((video.videoHeight - scanRegionSize) / 2),\n            width: scanRegionSize,\n            height: scanRegionSize,\n            downScaledWidth: this._legacyCanvasSize,\n            downScaledHeight: this._legacyCanvasSize,\n        };\n    }\n\n    private _updateOverlay(): void {\n        requestAnimationFrame(() => {\n            // Running in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle\n            // and offsetWidth, offsetHeight, offsetLeft, offsetTop.\n            if (!this.$overlay) return;\n            const video = this.$video;\n            const videoWidth = video.videoWidth;\n            const videoHeight = video.videoHeight;\n            const elementWidth = video.offsetWidth;\n            const elementHeight = video.offsetHeight;\n            const elementX = video.offsetLeft;\n            const elementY = video.offsetTop;\n\n            const videoStyle = window.getComputedStyle(video);\n            const videoObjectFit = videoStyle.objectFit;\n            const videoAspectRatio = videoWidth / videoHeight;\n            const elementAspectRatio = elementWidth / elementHeight;\n            let videoScaledWidth: number;\n            let videoScaledHeight: number;\n            switch (videoObjectFit) {\n                case 'none':\n                    videoScaledWidth = videoWidth;\n                    videoScaledHeight = videoHeight;\n                    break;\n                case 'fill':\n                    videoScaledWidth = elementWidth;\n                    videoScaledHeight = elementHeight;\n                    break;\n                default: // 'cover', 'contains', 'scale-down'\n                    if (videoObjectFit === 'cover'\n                        ? videoAspectRatio > elementAspectRatio\n                        : videoAspectRatio < elementAspectRatio) {\n                        // The scaled height is the element height\n                        // - for 'cover' if the video aspect ratio is wider than the element aspect ratio\n                        //   (scaled height matches element height and scaled width overflows element width)\n                        // - for 'contains'/'scale-down' if element aspect ratio is wider than the video aspect ratio\n                        //   (scaled height matched element height and element width overflows scaled width)\n                        videoScaledHeight = elementHeight;\n                        videoScaledWidth = videoScaledHeight * videoAspectRatio;\n                    } else {\n                        videoScaledWidth = elementWidth;\n                        videoScaledHeight = videoScaledWidth / videoAspectRatio;\n                    }\n                    if (videoObjectFit === 'scale-down') {\n                        // for 'scale-down' the dimensions are the minimum of 'contains' and 'none'\n                        videoScaledWidth = Math.min(videoScaledWidth, videoWidth);\n                        videoScaledHeight = Math.min(videoScaledHeight, videoHeight);\n                    }\n            }\n\n            // getComputedStyle is so nice to convert keywords (left, center, right, top, bottom) to percent and makes\n            // sure to set the default of 50% if only one or no component was provided, therefore we can be sure that\n            // both components are set. Additionally, it converts units other than px (e.g. rem) to px.\n            const [videoX, videoY] = videoStyle.objectPosition.split(' ').map((length, i) => {\n                const lengthValue = parseFloat(length);\n                return length.endsWith('%')\n                    ? (!i ? elementWidth - videoScaledWidth : elementHeight - videoScaledHeight) * lengthValue / 100\n                    : lengthValue;\n            });\n\n            const regionWidth = this._scanRegion.width || videoWidth;\n            const regionHeight = this._scanRegion.height || videoHeight;\n            const regionX = this._scanRegion.x || 0;\n            const regionY = this._scanRegion.y || 0;\n\n            const overlayStyle = this.$overlay.style;\n            overlayStyle.width = `${regionWidth / videoWidth * videoScaledWidth}px`;\n            overlayStyle.height = `${regionHeight / videoHeight * videoScaledHeight}px`;\n            overlayStyle.top = `${elementY + videoY + regionY / videoHeight * videoScaledHeight}px`;\n            const isVideoMirrored = /scaleX\\(-1\\)/.test(video.style.transform!);\n            overlayStyle.left = `${elementX\n                + (isVideoMirrored ? elementWidth - videoX - videoScaledWidth : videoX)\n                + (isVideoMirrored ? videoWidth - regionX - regionWidth : regionX) / videoWidth * videoScaledWidth}px`;\n            // apply same mirror as on video\n            overlayStyle.transform = video.style.transform;\n        });\n    }\n\n    private static _convertPoints(\n        points: QrScanner.Point[],\n        scanRegion?: QrScanner.ScanRegion | null,\n    ): QrScanner.Point[] {\n        if (!scanRegion) return points;\n        // create a new array so we don't mangle the original array's Points\n        let converted: QrScanner.Point[] = [];\n        const offsetX = scanRegion.x || 0;\n        const offsetY = scanRegion.y || 0;\n        const scaleFactorX = scanRegion.width && scanRegion.downScaledWidth\n            ? scanRegion.width / scanRegion.downScaledWidth\n            : 1;\n        const scaleFactorY = scanRegion.height && scanRegion.downScaledHeight\n            ? scanRegion.height / scanRegion.downScaledHeight\n            : 1;\n        for (const point of points) {\n            converted = [...converted, {\n                x: point.x * scaleFactorX + offsetX,\n                y: point.y * scaleFactorY + offsetY,\n            }]\n        }\n        return converted;\n    }\n\n    private _scanFrame(): void {\n        if (!this._active || this.$video.paused || this.$video.ended) return;\n        // If requestVideoFrameCallback is available use that to avoid unnecessary scans on the same frame as the\n        // camera's framerate can be lower than the screen refresh rate and this._maxScansPerSecond, especially in dark\n        // settings where the exposure time is longer. Both, requestVideoFrameCallback and requestAnimationFrame are not\n        // being fired if the tab is in the background, which is what we want.\n        const requestFrame = 'requestVideoFrameCallback' in this.$video\n            // @ts-ignore\n            ? this.$video.requestVideoFrameCallback.bind(this.$video)\n            : requestAnimationFrame;\n        requestFrame(async () => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n\n            const timeSinceLastScan = Date.now() - this._lastScanTimestamp;\n            const minimumTimeBetweenScans = 1000 / this._maxScansPerSecond;\n            if (timeSinceLastScan < minimumTimeBetweenScans) {\n                await new Promise((resolve) => setTimeout(resolve, minimumTimeBetweenScans - timeSinceLastScan));\n            }\n            // console.log('Scan rate:', Math.round(1000 / (Date.now() - this._lastScanTimestamp)));\n            this._lastScanTimestamp = Date.now();\n\n            let result: QrScanner.ScanResult | undefined;\n            try {\n                result = await QrScanner.scanImage(this.$video, {\n                    scanRegion: this._scanRegion,\n                    qrEngine: this._qrEngine,\n                    canvas: this.$canvas,\n                });\n            } catch (error) {\n                if (!this._active) return;\n                this._onDecodeError(error as Error | string);\n            }\n\n            if (QrScanner._disableBarcodeDetector && !(this._qrEngine instanceof Worker)) {\n                // replace the disabled BarcodeDetector\n                this._qrEngine = QrScanner.createQrEngine();\n            }\n\n            if (result) {\n                if (this._onDecode) {\n                    this._onDecode(result);\n                } else if (this._legacyOnDecode) {\n                    this._legacyOnDecode(result.data);\n                }\n\n                if (this.$codeOutlineHighlight) {\n                    clearTimeout(this._codeOutlineHighlightRemovalTimeout);\n                    this._codeOutlineHighlightRemovalTimeout = undefined;\n                    this.$codeOutlineHighlight.setAttribute(\n                        'viewBox',\n                        `${this._scanRegion.x || 0} `\n                            + `${this._scanRegion.y || 0} `\n                            + `${this._scanRegion.width || this.$video.videoWidth} `\n                            + `${this._scanRegion.height || this.$video.videoHeight}`,\n                    );\n                    const polygon = this.$codeOutlineHighlight.firstElementChild!;\n                    polygon.setAttribute('points', result.cornerPoints.map(({x, y}) => `${x},${y}`).join(' '));\n                    this.$codeOutlineHighlight.style.display = '';\n                }\n            } else if (this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout) {\n                // hide after timeout to make it flash less when on some frames the QR code is detected and on some not\n                this._codeOutlineHighlightRemovalTimeout = setTimeout(\n                    () => this.$codeOutlineHighlight!.style.display = 'none',\n                    100,\n                );\n            }\n\n            this._scanFrame();\n        });\n    }\n\n    private _onDecodeError(error: Error | string): void {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    private async _getCameraStream(): Promise<{ stream: MediaStream, facingMode: QrScanner.FacingMode }> {\n        if (!navigator.mediaDevices) throw 'Camera not found.';\n\n        const preferenceType = /^(environment|user)$/.test(this._preferredCamera)\n            ? 'facingMode'\n            : 'deviceId';\n        const constraintsWithoutCamera: Array<MediaTrackConstraints> = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {\n            [preferenceType]: { exact: this._preferredCamera },\n        }));\n\n        for (const constraints of [...constraintsWithCamera, ...constraintsWithoutCamera]) {\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });\n                // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as\n                // default. Note that the guess is not always accurate as Safari returns cameras of different facing\n                // mode, even for exact facingMode constraints.\n                const facingMode = this._getFacingMode(stream)\n                    || (constraints.facingMode\n                        ? this._preferredCamera as QrScanner.FacingMode // a facing mode we were able to fulfill\n                        : (this._preferredCamera === 'environment'\n                            ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it\n                            : 'environment' // switch from unfulfilled user facingMode or default to environment\n                        )\n                    );\n                return { stream, facingMode };\n            } catch (e) {}\n        }\n\n        throw 'Camera not found.';\n    }\n\n    private async _restartVideoStream(): Promise<void> {\n        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the\n        // stream might still be running, as it's by default only stopped after a delay of 300ms.\n        const wasPaused = this._paused;\n        const paused = await this.pause(true);\n        if (!paused || wasPaused || !this._active) return;\n        await this.start();\n    }\n\n    private static _stopVideoStream(stream : MediaStream): void {\n        for (const track of stream.getTracks()) {\n            track.stop(); //  note that this will also automatically turn the flashlight off\n            stream.removeTrack(track);\n        }\n    }\n\n    private _setVideoMirror(facingMode: QrScanner.FacingMode): void {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode === 'user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    private _getFacingMode(videoStream: MediaStream): QrScanner.FacingMode | null {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    private static _drawToCanvas(\n        image: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement,\n        scanRegion?: QrScanner.ScanRegion | null,\n        canvas?: HTMLCanvasElement | null,\n        disallowCanvasResizing= false,\n    ): [HTMLCanvasElement, CanvasRenderingContext2D] {\n        canvas = canvas || document.createElement('canvas');\n        const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0;\n        const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0;\n        const scanRegionWidth = scanRegion && scanRegion.width\n            ? scanRegion.width\n            : (image as HTMLVideoElement).videoWidth || image.width as number;\n        const scanRegionHeight = scanRegion && scanRegion.height\n            ? scanRegion.height\n            : (image as HTMLVideoElement).videoHeight || image.height as number;\n\n        if (!disallowCanvasResizing) {\n            const canvasWidth = scanRegion && scanRegion.downScaledWidth\n                ? scanRegion.downScaledWidth\n                : scanRegionWidth;\n            const canvasHeight = scanRegion && scanRegion.downScaledHeight\n                ? scanRegion.downScaledHeight\n                : scanRegionHeight;\n            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only\n            // set them if they actually changed.\n            if (canvas.width !== canvasWidth) {\n                canvas.width = canvasWidth;\n            }\n            if (canvas.height !== canvasHeight) {\n                canvas.height = canvasHeight;\n            }\n        }\n\n        const context = canvas.getContext('2d', { alpha: false })!;\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(\n            image,\n            scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight,\n            0, 0, canvas.width, canvas.height,\n        );\n        return [canvas, context];\n    }\n\n    private static async _loadImage(\n        imageOrFileOrBlobOrUrl: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n            | SVGImageElement | File | Blob | URL | String,\n    ): Promise<HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap\n        | SVGImageElement > {\n        if (imageOrFileOrBlobOrUrl instanceof Image) {\n            await QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl);\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement\n            || imageOrFileOrBlobOrUrl instanceof SVGImageElement\n            || 'OffscreenCanvas' in window && imageOrFileOrBlobOrUrl instanceof OffscreenCanvas\n            || 'ImageBitmap' in window && imageOrFileOrBlobOrUrl instanceof ImageBitmap) {\n            return imageOrFileOrBlobOrUrl;\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof imageOrFileOrBlobOrUrl === 'string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl.toString();\n            }\n            try {\n                await QrScanner._awaitImageLoad(image);\n                return image;\n            } finally {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n            }\n        } else {\n            throw 'Unsupported image type.';\n        }\n    }\n\n    private static async _awaitImageLoad(image: HTMLImageElement): Promise<void> {\n        if (image.complete && image.naturalWidth !== 0) return; // already loaded\n        await new Promise<void>((resolve, reject) => {\n            const listener = (event: ErrorEvent | Event) => {\n                image.removeEventListener('load', listener);\n                image.removeEventListener('error', listener);\n                if (event instanceof ErrorEvent) {\n                    reject('Image load error');\n                } else {\n                    resolve();\n                }\n            };\n            image.addEventListener('load', listener);\n            image.addEventListener('error', listener);\n        });\n    }\n\n    private static _postWorkerMessage(\n        qrEngineOrQrEnginePromise: Worker,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): number {\n        return QrScanner._postWorkerMessageSync(qrEngineOrQrEnginePromise, type, data, transfer);\n    }\n\n    // sync version of _postWorkerMessage without performance overhead of async functions\n    private static _postWorkerMessageSync(\n        qrEngine: Worker,\n        type: string,\n        data?: any,\n        transfer?: Transferable[],\n    ): number {\n        const id = QrScanner._workerMessageId++;\n        qrEngine.postMessage({\n            id,\n            type,\n            data,\n        }, transfer);\n        return id;\n    }\n}\n\ndeclare namespace QrScanner {\n    export interface ScanRegion {\n        x?: number;\n        y?: number;\n        width?: number;\n        height?: number;\n        downScaledWidth?: number;\n        downScaledHeight?: number;\n    }\n\n    export type FacingMode = 'environment' | 'user';\n    export type DeviceId = string;\n\n    export interface Camera {\n        id: DeviceId;\n        label: string;\n    }\n\n    export type InversionMode = 'original' | 'invert' | 'both';\n\n    export interface Point {\n        x: number;\n        y: number;\n    }\n\n    export interface ScanResult {\n        data: string;\n        // In clockwise order, starting at top left, but this might not be guaranteed in the future.\n        cornerPoints: QrScanner.Point[];\n        cornerPointsOrig: QrScanner.Point[];\n        scannedFrame?: Blob;\n    }\n}\n\n// simplified from https://wicg.github.io/shape-detection-api/#barcode-detection-api\ndeclare class BarcodeDetector {\n    constructor(options?: { formats: string[] });\n    static getSupportedFormats(): Promise<string[]>;\n    detect(image: ImageBitmapSource): Promise<Array<{ rawValue: string, cornerPoints: QrScanner.Point[] }>>;\n}\n\n// simplified from https://github.com/lukewarlow/user-agent-data-types/blob/master/index.d.ts\ndeclare global {\n    interface Navigator {\n        readonly userAgentData?: {\n            readonly platform: string;\n            readonly brands: Array<{\n                readonly brand: string;\n                readonly version: string;\n            }>;\n            getHighEntropyValues(hints: string[]): Promise<{\n                readonly architecture?: string;\n                readonly platformVersion?: string;\n            }>;\n        };\n    }\n}\n\nexport default QrScanner;\n"],"names":[],"mappings":"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"}