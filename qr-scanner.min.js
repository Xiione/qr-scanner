var rsiscool = (() => {
  var _scriptName = import.meta.url;
  
  return (
function(moduleArg = {}) {
  var moduleRtn;

var n=moduleArg,ca,da,ea=new Promise((a,b)=>{ca=a;da=b;}),fa=Object.assign({},n),ha="./this.program",p="",ia;"undefined"!=typeof document&&document.currentScript&&(p=document.currentScript.src);_scriptName&&(p=_scriptName);p.startsWith("blob:")?p="":p=p.substr(0,p.replace(/[?#].*/,"").lastIndexOf("/")+1);ia=(a,b,c)=>{fetch(a,{credentials:"same-origin"}).then(d=>d.ok?d.arrayBuffer():Promise.reject(Error(d.status+" : "+d.url))).then(b,c);};var v=n.printErr||console.error.bind(console);
Object.assign(n,fa);fa=null;n.thisProgram&&(ha=n.thisProgram);var x;n.wasmBinary&&(x=n.wasmBinary);var ja,ka=!1,y,A,B,la,C,D,ma,na,oa=[],pa=[],qa=[];function ra(){var a=n.preRun.shift();oa.unshift(a);}var E=0,F=null;function ta(a){n.onAbort?.(a);a="Aborted("+a+")";v(a);ka=!0;a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info.");da(a);throw a;}var ua=a=>a.startsWith("data:application/octet-stream;base64,"),va;
function wa(a){if(a==va&&x)return new Uint8Array(x);throw "both async and sync fetching of the wasm failed";}function xa(a){return x?Promise.resolve().then(()=>wa(a)):new Promise((b,c)=>{ia(a,d=>b(new Uint8Array(d)),()=>{try{b(wa(a));}catch(d){c(d);}});})}function ya(a,b,c){return xa(a).then(d=>WebAssembly.instantiate(d,b)).then(c,d=>{v(`failed to asynchronously prepare wasm: ${d}`);ta(d);})}
function za(a,b){var c=va;return x||"function"!=typeof WebAssembly.instantiateStreaming||ua(c)||"function"!=typeof fetch?ya(c,a,b):fetch(c,{credentials:"same-origin"}).then(d=>WebAssembly.instantiateStreaming(d,a).then(b,function(e){v(`wasm streaming compile failed: ${e}`);v("falling back to ArrayBuffer instantiation");return ya(c,a,b)}))}var Aa=a=>{for(;0<a.length;)a.shift()(n);};class Ba{constructor(a){this.S=a-24;}}var Ca=0,Ea={},Fa=a=>{for(;a.length;){var b=a.pop();a.pop()(b);}};
function H(a){return this.fromWireType(D[a>>2])}
var I={},J={},Ga={},K,M=(a,b,c)=>{function d(f){f=c(f);if(f.length!==a.length)throw new K("Mismatched type converter count");for(var m=0;m<a.length;++m)L(a[m],f[m]);}a.forEach(function(f){Ga[f]=b;});var e=Array(b.length),h=[],g=0;b.forEach((f,m)=>{J.hasOwnProperty(f)?e[m]=J[f]:(h.push(f),I.hasOwnProperty(f)||(I[f]=[]),I[f].push(()=>{e[m]=J[f];++g;g===h.length&&d(e);}));});0===h.length&&d(e);},Ia,N=a=>{for(var b="";A[a];)b+=Ia[A[a++]];return b},O,Ja=a=>{throw new O(a);};
function Ka(a,b,c={}){var d=b.name;if(!a)throw new O(`type "${d}" must have a positive integer typeid pointer`);if(J.hasOwnProperty(a)){if(c.va)return;throw new O(`Cannot register type '${d}' twice`);}J[a]=b;delete Ga[a];I.hasOwnProperty(a)&&(b=I[a],delete I[a],b.forEach(e=>e()));}function L(a,b,c={}){if(!("argPackAdvance"in b))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Ka(a,b,c)}
var La=a=>{throw new O(a.P.T.R.name+" instance already deleted");},Ma=!1,Na=()=>{},Oa=(a,b,c)=>{if(b===c)return a;if(void 0===c.W)return null;a=Oa(a,b,c.W);return null===a?null:c.oa(a)},Pa={},P=[],Qa=()=>{for(;P.length;){var a=P.pop();a.P.aa=!1;a["delete"]();}},Q,R={},Ra=(a,b)=>{if(void 0===b)throw new O("ptr should not be undefined");for(;a.W;)b=a.da(b),a=a.W;return R[b]},Sa=(a,b)=>{if(!b.T||!b.S)throw new K("makeClassHandle requires ptr and ptrType");if(!!b.X!==!!b.U)throw new K("Both smartPtrType and smartPtr must be specified");
b.count={value:1};return S(Object.create(a,{P:{value:b,writable:!0}}))},S=a=>{if("undefined"===typeof FinalizationRegistry)return S=b=>b,a;Ma=new FinalizationRegistry(b=>{b=b.P;--b.count.value;0===b.count.value&&(b.U?b.X.Z(b.U):b.T.R.Z(b.S));});S=b=>{var c=b.P;c.U&&Ma.register(b,{P:c},b);return b};Na=b=>{Ma.unregister(b);};return S(a)};function Ta(){}
var T=(a,b)=>Object.defineProperty(b,"name",{value:a}),Ua=(a,b,c)=>{if(void 0===a[b].V){var d=a[b];a[b]=function(...e){if(!a[b].V.hasOwnProperty(e.length))throw new O(`Function '${c}' called with an invalid number of arguments (${e.length}) - expects one of (${a[b].V})!`);return a[b].V[e.length].apply(this,e)};a[b].V=[];a[b].V[d.ea]=d;}},Va=(a,b,c)=>{if(n.hasOwnProperty(a)){if(void 0===c||void 0!==n[a].V&&void 0!==n[a].V[c])throw new O(`Cannot register public name '${a}' twice`);Ua(n,a,a);if(n.hasOwnProperty(c))throw new O(`Cannot register multiple overloads of a function with the same number of arguments (${c})!`);
n[a].V[c]=b;}else n[a]=b,void 0!==c&&(n[a].Ea=c);},Wa=a=>{if(void 0===a)return "_unknown";a=a.replace(/[^a-zA-Z0-9_]/g,"$");var b=a.charCodeAt(0);return 48<=b&&57>=b?`_${a}`:a};function Xa(a,b,c,d,e,h,g,f){this.name=a;this.constructor=b;this.ba=c;this.Z=d;this.W=e;this.qa=h;this.da=g;this.oa=f;this.ya=[];}var Ya=(a,b,c)=>{for(;b!==c;){if(!b.da)throw new O(`Expected null or instance of ${c.name}, got an instance of ${b.name}`);a=b.da(a);b=b.W;}return a};
function Za(a,b){if(null===b){if(this.ha)throw new O(`null is not a valid ${this.name}`);return 0}if(!b.P)throw new O(`Cannot pass "${$a(b)}" as a ${this.name}`);if(!b.P.S)throw new O(`Cannot pass deleted object as a pointer of type ${this.name}`);return Ya(b.P.S,b.P.T.R,this.R)}
function ab(a,b){if(null===b){if(this.ha)throw new O(`null is not a valid ${this.name}`);if(this.ga){var c=this.ia();null!==a&&a.push(this.Z,c);return c}return 0}if(!b||!b.P)throw new O(`Cannot pass "${$a(b)}" as a ${this.name}`);if(!b.P.S)throw new O(`Cannot pass deleted object as a pointer of type ${this.name}`);if(!this.fa&&b.P.T.fa)throw new O(`Cannot convert argument of type ${b.P.X?b.P.X.name:b.P.T.name} to parameter type ${this.name}`);c=Ya(b.P.S,b.P.T.R,this.R);if(this.ga){if(void 0===b.P.U)throw new O("Passing raw pointer to smart pointer is illegal");
switch(this.Da){case 0:if(b.P.X===this)c=b.P.U;else throw new O(`Cannot convert argument of type ${b.P.X?b.P.X.name:b.P.T.name} to parameter type ${this.name}`);break;case 1:c=b.P.U;break;case 2:if(b.P.X===this)c=b.P.U;else {var d=b.clone();c=this.za(c,U(()=>d["delete"]()));null!==a&&a.push(this.Z,c);}break;default:throw new O("Unsupporting sharing policy");}}return c}
function bb(a,b){if(null===b){if(this.ha)throw new O(`null is not a valid ${this.name}`);return 0}if(!b.P)throw new O(`Cannot pass "${$a(b)}" as a ${this.name}`);if(!b.P.S)throw new O(`Cannot pass deleted object as a pointer of type ${this.name}`);if(b.P.T.fa)throw new O(`Cannot convert argument of type ${b.P.T.name} to parameter type ${this.name}`);return Ya(b.P.S,b.P.T.R,this.R)}
function cb(a,b,c,d,e,h,g,f,m,l,k){this.name=a;this.R=b;this.ha=c;this.fa=d;this.ga=e;this.xa=h;this.Da=g;this.ma=f;this.ia=m;this.za=l;this.Z=k;e||void 0!==b.W?this.toWireType=ab:(this.toWireType=d?Za:bb,this.Y=null);}
var db=(a,b,c)=>{if(!n.hasOwnProperty(a))throw new K("Replacing nonexistent public symbol");void 0!==n[a].V&&void 0!==c?n[a].V[c]=b:(n[a]=b,n[a].ea=c);},eb=[],fb,gb=a=>{var b=eb[a];b||(a>=eb.length&&(eb.length=a+1),eb[a]=b=fb.get(a));return b},hb=(a,b,c=[])=>{a.includes("j")?(a=a.replace(/p/g,"i"),b=(0, n["dynCall_"+a])(b,...c)):b=gb(b)(...c);return b},ib=(a,b)=>(...c)=>hb(a,b,c),V=(a,b)=>{a=N(a);var c=a.includes("j")?ib(a,b):gb(b);if("function"!=typeof c)throw new O(`unknown function pointer with signature ${a}: ${b}`);
return c},jb,lb=a=>{a=kb(a);var b=N(a);W(a);return b},mb=(a,b)=>{function c(h){e[h]||J[h]||(Ga[h]?Ga[h].forEach(c):(d.push(h),e[h]=!0));}var d=[],e={};b.forEach(c);throw new jb(`${a}: `+d.map(lb).join([", "]));},nb=(a,b)=>{for(var c=[],d=0;d<a;d++)c.push(D[b+4*d>>2]);return c};function ob(a){for(var b=1;b<a.length;++b)if(null!==a[b]&&void 0===a[b].Y)return !0;return !1}
function pb(a){var b=Function;if(!(b instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof b} which is not a function`);var c=T(b.name||"unknownFunctionName",function(){});c.prototype=b.prototype;c=new c;a=b.apply(c,a);return a instanceof Object?a:c}
function qb(a,b,c,d,e,h){var g=b.length;if(2>g)throw new O("argTypes array size mismatch! Must at least get return value and 'this' types!");var f=null!==b[1]&&null!==c,m=ob(b);c="void"!==b[0].name;d=[a,Ja,d,e,Fa,b[0],b[1]];for(e=0;e<g-2;++e)d.push(b[e+2]);if(!m)for(e=f?1:2;e<b.length;++e)null!==b[e].Y&&d.push(b[e].Y);m=ob(b);e=b.length;var l="",k="";for(g=0;g<e-2;++g)l+=(0!==g?", ":"")+"arg"+g,k+=(0!==g?", ":"")+"arg"+g+"Wired";l=`\n        return function (${l}) {\n        if (arguments.length !== ${e-
2}) {\n          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${e-2}');\n        }`;m&&(l+="var destructors = [];\n");var r=m?"destructors":"null",q="humanName throwBindingError invoker fn runDestructors retType classParam".split(" ");f&&(l+="var thisWired = classParam['toWireType']("+r+", this);\n");for(g=0;g<e-2;++g)l+="var arg"+g+"Wired = argType"+g+"['toWireType']("+r+", arg"+g+");\n",q.push("argType"+g);f&&(k="thisWired"+(0<k.length?", ":
"")+k);l+=(c||h?"var rv = ":"")+"invoker(fn"+(0<k.length?", ":"")+k+");\n";if(m)l+="runDestructors(destructors);\n";else for(g=f?1:2;g<b.length;++g)h=1===g?"thisWired":"arg"+(g-2)+"Wired",null!==b[g].Y&&(l+=`${h}_dtor(${h});\n`,q.push(`${h}_dtor`));c&&(l+="var ret = retType['fromWireType'](rv);\nreturn ret;\n");let [w,u]=[q,l+"}\n"];w.push(u);b=pb(w)(...d);return T(a,b)}
var rb=a=>{a=a.trim();const b=a.indexOf("(");return -1!==b?a.substr(0,b):a},sb=[],X=[],ub=a=>{9<a&&0===--X[a+1]&&(X[a]=void 0,sb.push(a));},Y=a=>{if(!a)throw new O("Cannot use deleted val. handle = "+a);return X[a]},U=a=>{switch(a){case void 0:return 2;case null:return 4;case !0:return 6;case !1:return 8;default:const b=sb.pop()||X.length;X[b]=a;X[b+1]=1;return b}},vb={name:"emscripten::val",fromWireType:a=>{var b=Y(a);ub(a);return b},toWireType:(a,b)=>U(b),argPackAdvance:8,readValueFromPointer:H,Y:null},
$a=a=>{if(null===a)return "null";var b=typeof a;return "object"===b||"array"===b||"function"===b?a.toString():""+a},wb=(a,b)=>{switch(b){case 4:return function(c){return this.fromWireType(ma[c>>2])};case 8:return function(c){return this.fromWireType(na[c>>3])};default:throw new TypeError(`invalid float width (${b}): ${a}`);}},xb=(a,b,c)=>{switch(b){case 1:return c?d=>y[d]:d=>A[d];case 2:return c?d=>B[d>>1]:d=>la[d>>1];case 4:return c?d=>C[d>>2]:d=>D[d>>2];default:throw new TypeError(`invalid integer width (${b}): ${a}`);
}},yb="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0,zb="undefined"!=typeof TextDecoder?new TextDecoder("utf-16le"):void 0,Ab=(a,b)=>{var c=a>>1;for(var d=c+b/2;!(c>=d)&&la[c];)++c;c<<=1;if(32<c-a&&zb)return zb.decode(A.subarray(a,c));c="";for(d=0;!(d>=b/2);++d){var e=B[a+2*d>>1];if(0==e)break;c+=String.fromCharCode(e);}return c},Bb=(a,b,c)=>{c??=2147483647;if(2>c)return 0;c-=2;var d=b;c=c<2*a.length?c/2:a.length;for(var e=0;e<c;++e)B[b>>1]=a.charCodeAt(e),b+=2;B[b>>1]=0;return b-d},
Cb=a=>2*a.length,Db=(a,b)=>{for(var c=0,d="";!(c>=b/4);){var e=C[a+4*c>>2];if(0==e)break;++c;65536<=e?(e-=65536,d+=String.fromCharCode(55296|e>>10,56320|e&1023)):d+=String.fromCharCode(e);}return d},Eb=(a,b,c)=>{c??=2147483647;if(4>c)return 0;var d=b;c=d+c-4;for(var e=0;e<a.length;++e){var h=a.charCodeAt(e);if(55296<=h&&57343>=h){var g=a.charCodeAt(++e);h=65536+((h&1023)<<10)|g&1023;}C[b>>2]=h;b+=4;if(b+4>c)break}C[b>>2]=0;return b-d},Fb=a=>{for(var b=0,c=0;c<a.length;++c){var d=a.charCodeAt(c);55296<=
d&&57343>=d&&++c;b+=4;}return b},Gb=(a,b)=>{var c=J[a];if(void 0===c)throw a=`${b} has unknown type ${lb(a)}`,new O(a);return c},Hb=(a,b,c)=>{var d=[];a=a.toWireType(d,c);d.length&&(D[b>>2]=U(d));return a},Ib=[],Jb={},Kb=a=>{var b=Jb[a];return void 0===b?N(a):b},Lb=()=>"object"==typeof globalThis?globalThis:Function("return this")(),Mb=a=>{var b=Ib.length;Ib.push(a);return b},Nb=(a,b)=>{for(var c=Array(a),d=0;d<a;++d)c[d]=Gb(D[b+4*d>>2],"parameter "+d);return c},Ob={},Qb=()=>{if(!Pb){var a={USER:"web_user",
LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:ha||"./this.program"},b;for(b in Ob)void 0===Ob[b]?delete a[b]:a[b]=Ob[b];var c=[];for(b in a)c.push(`${b}=${a[b]}`);Pb=c;}return Pb},Pb;K=n.InternalError=class extends Error{constructor(a){super(a);this.name="InternalError";}};for(var Rb=Array(256),Sb=0;256>Sb;++Sb)Rb[Sb]=String.fromCharCode(Sb);Ia=Rb;
O=n.BindingError=class extends Error{constructor(a){super(a);this.name="BindingError";}};
Object.assign(Ta.prototype,{isAliasOf:function(a){if(!(this instanceof Ta&&a instanceof Ta))return !1;var b=this.P.T.R,c=this.P.S;a.P=a.P;var d=a.P.T.R;for(a=a.P.S;b.W;)c=b.da(c),b=b.W;for(;d.W;)a=d.da(a),d=d.W;return b===d&&c===a},clone:function(){this.P.S||La(this);if(this.P.ca)return this.P.count.value+=1,this;var a=S,b=Object,c=b.create,d=Object.getPrototypeOf(this),e=this.P;a=a(c.call(b,d,{P:{value:{count:e.count,aa:e.aa,ca:e.ca,S:e.S,T:e.T,U:e.U,X:e.X}}}));a.P.count.value+=1;a.P.aa=!1;return a},
["delete"](){this.P.S||La(this);if(this.P.aa&&!this.P.ca)throw new O("Object already scheduled for deletion");Na(this);var a=this.P;--a.count.value;0===a.count.value&&(a.U?a.X.Z(a.U):a.T.R.Z(a.S));this.P.ca||(this.P.U=void 0,this.P.S=void 0);},isDeleted:function(){return !this.P.S},deleteLater:function(){this.P.S||La(this);if(this.P.aa&&!this.P.ca)throw new O("Object already scheduled for deletion");P.push(this);1===P.length&&Q&&Q(Qa);this.P.aa=!0;return this}});n.getInheritedInstanceCount=()=>Object.keys(R).length;
n.getLiveInheritedInstances=()=>{var a=[],b;for(b in R)R.hasOwnProperty(b)&&a.push(R[b]);return a};n.flushPendingDeletes=Qa;n.setDelayFunction=a=>{Q=a;P.length&&Q&&Q(Qa);};
Object.assign(cb.prototype,{ra(a){this.ma&&(a=this.ma(a));return a},ka(a){this.Z?.(a);},argPackAdvance:8,readValueFromPointer:H,fromWireType:function(a){function b(){return this.ga?Sa(this.R.ba,{T:this.xa,S:c,X:this,U:a}):Sa(this.R.ba,{T:this,S:a})}var c=this.ra(a);if(!c)return this.ka(a),null;var d=Ra(this.R,c);if(void 0!==d){if(0===d.P.count.value)return d.P.S=c,d.P.U=a,d.clone();d=d.clone();this.ka(a);return d}d=this.R.qa(c);d=Pa[d];if(!d)return b.call(this);d=this.fa?d.na:d.pointerType;var e=Oa(c,
this.R,d.R);return null===e?b.call(this):this.ga?Sa(d.R.ba,{T:d,S:e,X:this,U:a}):Sa(d.R.ba,{T:d,S:e})}});jb=n.UnboundTypeError=((a,b)=>{var c=T(b,function(d){this.name=b;this.message=d;d=Error(d).stack;void 0!==d&&(this.stack=this.toString()+"\n"+d.replace(/^Error(:[^\n]*)?\n/,""));});c.prototype=Object.create(a.prototype);c.prototype.constructor=c;c.prototype.toString=function(){return void 0===this.message?this.name:`${this.name}: ${this.message}`};return c})(Error,"UnboundTypeError");
X.push(0,1,void 0,1,null,1,!0,1,!1,1);n.count_emval_handles=()=>X.length/2-5-sb.length;
var Ub={l:(a,b,c)=>{var d=new Ba(a);D[d.S+16>>2]=0;D[d.S+4>>2]=b;D[d.S+8>>2]=c;Ca=a;throw Ca;},y:()=>{ta("");},F:a=>{var b=Ea[a];delete Ea[a];var c=b.ia,d=b.Z,e=b.la,h=e.map(g=>g.ua).concat(e.map(g=>g.Ba));M([a],h,g=>{var f={};e.forEach((m,l)=>{var k=g[l],r=m.sa,q=m.ta,w=g[l+e.length],u=m.Aa,t=m.Ca;f[m.pa]={read:G=>k.fromWireType(r(q,G)),write:(G,aa)=>{var z=[];u(t,G,w.toWireType(z,aa));Fa(z);}};});return [{name:b.name,fromWireType:m=>{var l={},k;for(k in f)l[k]=f[k].read(m);d(m);return l},toWireType:(m,
l)=>{for(var k in f)if(!(k in l))throw new TypeError(`Missing field: "${k}"`);var r=c();for(k in f)f[k].write(r,l[k]);null!==m&&m.push(d,r);return r},argPackAdvance:8,readValueFromPointer:H,Y:d}]});},t:()=>{},A:(a,b,c,d)=>{b=N(b);L(a,{name:b,fromWireType:function(e){return !!e},toWireType:function(e,h){return h?c:d},argPackAdvance:8,readValueFromPointer:function(e){return this.fromWireType(A[e])},Y:null});},D:(a,b,c,d,e,h,g,f,m,l,k,r,q)=>{k=N(k);h=V(e,h);f&&=V(g,f);l&&=V(m,l);q=V(r,q);var w=Wa(k);Va(w,
function(){mb(`Cannot construct ${k} due to unbound types`,[d]);});M([a,b,c],d?[d]:[],u=>{u=u[0];if(d){var t=u.R;var G=t.ba;}else G=Ta.prototype;u=T(k,function(...Ha){if(Object.getPrototypeOf(this)!==aa)throw new O("Use 'new' to construct "+k);if(void 0===z.$)throw new O(k+" has no accessible constructor");var tb=z.$[Ha.length];if(void 0===tb)throw new O(`Tried to invoke ctor of ${k} with invalid number of parameters (${Ha.length}) - expected (${Object.keys(z.$).toString()}) parameters instead!`);return tb.apply(this,
Ha)});var aa=Object.create(G,{constructor:{value:u}});u.prototype=aa;var z=new Xa(k,u,aa,q,t,h,f,l);if(z.W){var ba;(ba=z.W).ja??(ba.ja=[]);z.W.ja.push(z);}t=new cb(k,z,!0,!1,!1);ba=new cb(k+"*",z,!1,!1,!1);G=new cb(k+" const*",z,!1,!0,!1);Pa[a]={pointerType:ba,na:G};db(w,u);return [t,ba,G]});},C:(a,b,c,d,e,h)=>{var g=nb(b,c);e=V(d,e);M([],[a],f=>{f=f[0];var m=`constructor ${f.name}`;void 0===f.R.$&&(f.R.$=[]);if(void 0!==f.R.$[b-1])throw new O(`Cannot register multiple constructors with identical number of parameters (${b-
1}) for class '${f.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);f.R.$[b-1]=()=>{mb(`Cannot construct ${f.name} due to unbound types`,g);};M([],g,l=>{l.splice(1,0,null);f.R.$[b-1]=qb(m,l,null,e,h);return []});return []});},d:(a,b,c,d,e,h,g,f,m)=>{var l=nb(c,d);b=N(b);b=rb(b);h=V(e,h);M([],[a],k=>{function r(){mb(`Cannot call ${q} due to unbound types`,l);}k=k[0];var q=`${k.name}.${b}`;b.startsWith("@@")&&(b=Symbol[b.substring(2)]);f&&k.R.ya.push(b);
var w=k.R.ba,u=w[b];void 0===u||void 0===u.V&&u.className!==k.name&&u.ea===c-2?(r.ea=c-2,r.className=k.name,w[b]=r):(Ua(w,b,q),w[b].V[c-2]=r);M([],l,t=>{t=qb(q,t,k,h,g,m);void 0===w[b].V?(t.ea=c-2,w[b]=t):w[b].V[c-2]=t;return []});return []});},z:a=>L(a,vb),j:(a,b,c)=>{b=N(b);L(a,{name:b,fromWireType:d=>d,toWireType:(d,e)=>e,argPackAdvance:8,readValueFromPointer:wb(b,c),Y:null});},E:(a,b,c,d,e,h,g)=>{var f=nb(b,c);a=N(a);a=rb(a);e=V(d,e);Va(a,function(){mb(`Cannot call ${a} due to unbound types`,f);},
b-1);M([],f,m=>{db(a,qb(a,[m[0],null].concat(m.slice(1)),null,e,h,g),b-1);return []});},c:(a,b,c,d,e)=>{b=N(b);-1===e&&(e=4294967295);e=f=>f;if(0===d){var h=32-8*c;e=f=>f<<h>>>h;}var g=b.includes("unsigned")?function(f,m){return m>>>0}:function(f,m){return m};L(a,{name:b,fromWireType:e,toWireType:g,argPackAdvance:8,readValueFromPointer:xb(b,c,0!==d),Y:null});},a:(a,b,c)=>{function d(h){return new e(y.buffer,D[h+4>>2],D[h>>2])}var e=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,
Float64Array][b];c=N(c);L(a,{name:c,fromWireType:d,argPackAdvance:8,readValueFromPointer:d},{va:!0});},o:a=>{L(a,vb);},k:(a,b)=>{b=N(b);var c="std::string"===b;L(a,{name:b,fromWireType:function(d){var e=D[d>>2],h=d+4;if(c)for(var g=h,f=0;f<=e;++f){var m=h+f;if(f==e||0==A[m]){if(g){var l=g;var k=A,r=l+(m-g);for(g=l;k[g]&&!(g>=r);)++g;if(16<g-l&&k.buffer&&yb)l=yb.decode(k.subarray(l,g));else {for(r="";l<g;){var q=k[l++];if(q&128){var w=k[l++]&63;if(192==(q&224))r+=String.fromCharCode((q&31)<<6|w);else {var u=
k[l++]&63;q=224==(q&240)?(q&15)<<12|w<<6|u:(q&7)<<18|w<<12|u<<6|k[l++]&63;65536>q?r+=String.fromCharCode(q):(q-=65536,r+=String.fromCharCode(55296|q>>10,56320|q&1023));}}else r+=String.fromCharCode(q);}l=r;}}else l="";if(void 0===t)var t=l;else t+=String.fromCharCode(0),t+=l;g=m+1;}}else {t=Array(e);for(f=0;f<e;++f)t[f]=String.fromCharCode(A[h+f]);t=t.join("");}W(d);return t},toWireType:function(d,e){e instanceof ArrayBuffer&&(e=new Uint8Array(e));var h,g="string"==typeof e;if(!(g||e instanceof Uint8Array||
e instanceof Uint8ClampedArray||e instanceof Int8Array))throw new O("Cannot pass non-string to std::string");var f;if(c&&g)for(h=f=0;h<e.length;++h){var m=e.charCodeAt(h);127>=m?f++:2047>=m?f+=2:55296<=m&&57343>=m?(f+=4,++h):f+=3;}else f=e.length;h=f;f=Tb(4+h+1);m=f+4;D[f>>2]=h;if(c&&g){if(g=m,m=h+1,h=A,0<m){m=g+m-1;for(var l=0;l<e.length;++l){var k=e.charCodeAt(l);if(55296<=k&&57343>=k){var r=e.charCodeAt(++l);k=65536+((k&1023)<<10)|r&1023;}if(127>=k){if(g>=m)break;h[g++]=k;}else {if(2047>=k){if(g+1>=
m)break;h[g++]=192|k>>6;}else {if(65535>=k){if(g+2>=m)break;h[g++]=224|k>>12;}else {if(g+3>=m)break;h[g++]=240|k>>18;h[g++]=128|k>>12&63;}h[g++]=128|k>>6&63;}h[g++]=128|k&63;}}h[g]=0;}}else if(g)for(g=0;g<h;++g){l=e.charCodeAt(g);if(255<l)throw W(m),new O("String has UTF-16 code units that do not fit in 8 bits");A[m+g]=l;}else for(g=0;g<h;++g)A[m+g]=e[g];null!==d&&d.push(W,f);return f},argPackAdvance:8,readValueFromPointer:H,Y(d){W(d);}});},f:(a,b,c)=>{c=N(c);if(2===b){var d=Ab;var e=Bb;var h=Cb;var g=f=>la[f>>
1];}else 4===b&&(d=Db,e=Eb,h=Fb,g=f=>D[f>>2]);L(a,{name:c,fromWireType:f=>{for(var m=D[f>>2],l,k=f+4,r=0;r<=m;++r){var q=f+4+r*b;if(r==m||0==g(q))k=d(k,q-k),void 0===l?l=k:(l+=String.fromCharCode(0),l+=k),k=q+b;}W(f);return l},toWireType:(f,m)=>{if("string"!=typeof m)throw new O(`Cannot pass non-string to C++ string type ${c}`);var l=h(m),k=Tb(4+l+b);D[k>>2]=l/b;e(m,k+4,l+b);null!==f&&f.push(W,k);return k},argPackAdvance:8,readValueFromPointer:H,Y(f){W(f);}});},G:(a,b,c,d,e,h)=>{Ea[a]={name:N(b),ia:V(c,
d),Z:V(e,h),la:[]};},p:(a,b,c,d,e,h,g,f,m,l)=>{Ea[a].la.push({pa:N(b),ua:c,sa:V(d,e),ta:h,Ba:g,Aa:V(f,m),Ca:l});},B:(a,b)=>{b=N(b);L(a,{wa:!0,name:b,argPackAdvance:0,fromWireType:()=>{},toWireType:()=>{}});},x:(a,b,c)=>A.copyWithin(a,b,b+c),i:(a,b,c)=>{a=Y(a);b=Gb(b,"emval::as");return Hb(b,c,a)},r:(a,b,c,d)=>{a=Ib[a];b=Y(b);return a(null,b,c,d)},H:(a,b,c,d,e)=>{a=Ib[a];b=Y(b);c=Kb(c);return a(b,b[c],d,e)},b:ub,s:a=>{if(0===a)return U(Lb());a=Kb(a);return U(Lb()[a])},g:(a,b,c)=>{b=Nb(a,b);var d=b.shift();
a--;var e="return function (obj, func, destructorsRef, args) {\n",h=0,g=[];0===c&&g.push("obj");for(var f=["retType"],m=[d],l=0;l<a;++l)g.push("arg"+l),f.push("argType"+l),m.push(b[l]),e+=`  var arg${l} = argType${l}.readValueFromPointer(args${h?"+"+h:""});\n`,h+=b[l].argPackAdvance;e+=`  var rv = ${1===c?"new func":"func.call"}(${g.join(", ")});\n`;d.wa||(f.push("emval_returnValue"),m.push(Hb),e+="  return emval_returnValue(retType, destructorsRef, rv);\n");f.push(e+"};\n");a=pb(f)(...m);c=`methodCaller<(${b.map(k=>
k.name).join(", ")}) => ${d.name}>`;return Mb(T(c,a))},I:a=>{a=Kb(a);return U(n[a])},m:(a,b)=>{a=Y(a);b=Y(b);return U(a[b])},h:a=>{9<a&&(X[a+1]+=1);},q:a=>U(Kb(a)),e:a=>{var b=Y(a);Fa(b);ub(a);},n:(a,b)=>{a=Gb(a,"_emval_take_value");a=a.readValueFromPointer(b);return U(a)},w:()=>{ta("OOM");},u:(a,b)=>{var c=0;Qb().forEach((d,e)=>{var h=b+c;e=D[a+4*e>>2]=h;for(h=0;h<d.length;++h)y[e++]=d.charCodeAt(h);y[e]=0;c+=d.length+1;});return 0},v:(a,b)=>{var c=Qb();D[a>>2]=c.length;var d=0;c.forEach(e=>d+=e.length+
1);D[b>>2]=d;return 0}},Z=function(){function a(c){Z=c.exports;ja=Z.J;c=ja.buffer;n.HEAP8=y=new Int8Array(c);n.HEAP16=B=new Int16Array(c);n.HEAPU8=A=new Uint8Array(c);n.HEAPU16=la=new Uint16Array(c);n.HEAP32=C=new Int32Array(c);n.HEAPU32=D=new Uint32Array(c);n.HEAPF32=ma=new Float32Array(c);n.HEAPF64=na=new Float64Array(c);fb=Z.M;pa.unshift(Z.K);E--;n.monitorRunDependencies?.(E);0==E&&(F&&(c=F,F=null,c()));return Z}var b={a:Ub};E++;n.monitorRunDependencies?.(E);
if(n.instantiateWasm)try{return n.instantiateWasm(b,a)}catch(c){v(`Module.instantiateWasm callback failed with error: ${c}`),da(c);}va||=n.locateFile?ua("rsiscool.wasm")?"rsiscool.wasm":n.locateFile?n.locateFile("rsiscool.wasm",p):p+"rsiscool.wasm":(new URL("rsiscool.wasm",import.meta.url)).href;za(b,function(c){a(c.instance);}).catch(da);return {}}(),kb=a=>(kb=Z.L)(a),Tb=a=>(Tb=Z.N)(a),W=a=>(W=Z.O)(a),Vb;F=function Wb(){Vb||Xb();Vb||(F=Wb);};
function Xb(){function a(){if(!Vb&&(Vb=!0,n.calledRun=!0,!ka)){Aa(pa);ca(n);if(n.onRuntimeInitialized)n.onRuntimeInitialized();if(n.postRun)for("function"==typeof n.postRun&&(n.postRun=[n.postRun]);n.postRun.length;){var b=n.postRun.shift();qa.unshift(b);}Aa(qa);}}if(!(0<E)){if(n.preRun)for("function"==typeof n.preRun&&(n.preRun=[n.preRun]);n.preRun.length;)ra();Aa(oa);0<E||(n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("");},1);a();},1)):a());}}
if(n.preInit)for("function"==typeof n.preInit&&(n.preInit=[n.preInit]);0<n.preInit.length;)n.preInit.pop()();Xb();moduleRtn=ea;


  return moduleRtn;
}
);
})();

let wasmModule;
async function initDecoder() {
    if (!wasmModule)
        wasmModule = await rsiscool();
}

class QrScanner {
    /** @deprecated */
    static set WORKER_PATH(workerPath) {
        console.warn('Setting QrScanner.WORKER_PATH is not required and not supported anymore. '
            + 'Have a look at the README for new setup instructions.');
    }
    static async hasCamera() {
        try {
            return !!(await QrScanner.listCameras(false)).length;
        }
        catch (e) {
            return false;
        }
    }
    static async listCameras(requestLabels = false) {
        if (!navigator.mediaDevices)
            return [];
        const enumerateCameras = async () => (await navigator.mediaDevices.enumerateDevices()).filter((device) => device.kind === 'videoinput');
        // Note that enumerateDevices can always be called and does not prompt the user for permission.
        // However, enumerateDevices only includes device labels if served via https and an active media stream exists
        // or permission to access the camera was given. Therefore, if we're not getting labels but labels are requested
        // ask for camera permission by opening a stream.
        let openedStream;
        try {
            if (requestLabels && (await enumerateCameras()).every((camera) => !camera.label)) {
                openedStream = await navigator.mediaDevices.getUserMedia({ audio: false, video: true });
            }
        }
        catch (e) {
            // Fail gracefully, especially if the device has no camera or on mobile when the camera is already in use
            // and some browsers disallow a second stream.
        }
        try {
            return (await enumerateCameras()).map((camera, i) => ({
                id: camera.deviceId,
                label: camera.label || (i === 0 ? 'Default Camera' : `Camera ${i + 1}`),
            }));
        }
        finally {
            // close the stream we just opened for getting camera access for listing the device labels
            if (openedStream) {
                console.warn('Call listCameras after successfully starting a QR scanner to avoid creating '
                    + 'a temporary video stream');
                QrScanner._stopVideoStream(openedStream);
            }
        }
    }
    constructor(video, onDecode, canvasSizeOrOnDecodeErrorOrOptions, canvasSizeOrCalculateScanRegion, preferredCamera) {
        this._legacyCanvasSize = QrScanner.DEFAULT_CANVAS_SIZE;
        this._preferredCamera = 'environment';
        this._maxScansPerSecond = 25;
        this._lastScanTimestamp = -1;
        this._active = false;
        this._paused = false;
        this._flashOn = false;
        this._destroyed = false;
        this.$video = video;
        this.$canvas = document.createElement('canvas');
        if (canvasSizeOrOnDecodeErrorOrOptions && typeof canvasSizeOrOnDecodeErrorOrOptions === 'object') {
            // we got an options object using the new api
            this._onDecode = onDecode;
        }
        else {
            if (canvasSizeOrOnDecodeErrorOrOptions || canvasSizeOrCalculateScanRegion || preferredCamera) {
                console.warn('You\'re using a deprecated version of the QrScanner constructor which will be removed in '
                    + 'the future');
            }
            else {
                // Only video and onDecode were specified and we can't distinguish between new or old api usage. For
                // backwards compatibility we have to assume the old api for now. The options object is marked as non-
                // optional in the parameter list above to make clear that ScanResult instead of string is only passed
                // if an options object was provided. However, in the future once legacy support is removed, the options
                // object should become optional.
                console.warn('Note that the type of the scan result passed to onDecode will change in the future. '
                    + 'To already switch to the new api today, you can pass returnDetailedScanResult: true.');
            }
            this._legacyOnDecode = onDecode;
        }
        const options = typeof canvasSizeOrOnDecodeErrorOrOptions === 'object'
            ? canvasSizeOrOnDecodeErrorOrOptions
            : {};
        this._onDecodeError = options.onDecodeError || (typeof canvasSizeOrOnDecodeErrorOrOptions === 'function'
            ? canvasSizeOrOnDecodeErrorOrOptions
            : this._onDecodeError);
        this._calculateScanRegion = options.calculateScanRegion || (typeof canvasSizeOrCalculateScanRegion === 'function'
            ? canvasSizeOrCalculateScanRegion
            : this._calculateScanRegion);
        this._preferredCamera = options.preferredCamera || preferredCamera || this._preferredCamera;
        this._legacyCanvasSize = typeof canvasSizeOrOnDecodeErrorOrOptions === 'number'
            ? canvasSizeOrOnDecodeErrorOrOptions
            : typeof canvasSizeOrCalculateScanRegion === 'number'
                ? canvasSizeOrCalculateScanRegion
                : this._legacyCanvasSize;
        this._maxScansPerSecond = options.maxScansPerSecond || this._maxScansPerSecond;
        this._onPlay = this._onPlay.bind(this);
        this._onLoadedMetaData = this._onLoadedMetaData.bind(this);
        this._onVisibilityChange = this._onVisibilityChange.bind(this);
        this._updateOverlay = this._updateOverlay.bind(this);
        // @ts-ignore
        video.disablePictureInPicture = true;
        // Allow inline playback on iPhone instead of requiring full screen playback,
        // see https://webkit.org/blog/6784/new-video-policies-for-ios/
        // @ts-ignore
        video.playsInline = true;
        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream
        // includes no audio, but just to be safe.
        video.muted = true;
        // Avoid Safari stopping the video stream on a hidden video.
        // See https://github.com/cozmo/jsQR/issues/185
        let shouldHideVideo = false;
        if (video.hidden) {
            video.hidden = false;
            shouldHideVideo = true;
        }
        if (!document.body.contains(video)) {
            document.body.appendChild(video);
            shouldHideVideo = true;
        }
        const videoContainer = video.parentElement;
        if (options.highlightScanRegion || options.highlightCodeOutline) {
            const gotExternalOverlay = !!options.overlay;
            this.$overlay = options.overlay || document.createElement('div');
            const overlayStyle = this.$overlay.style;
            overlayStyle.position = 'absolute';
            overlayStyle.display = 'none';
            overlayStyle.pointerEvents = 'none';
            this.$overlay.classList.add('scan-region-highlight');
            if (!gotExternalOverlay && options.highlightScanRegion) {
                // default style; can be overwritten via css, e.g. by changing the svg's stroke color, hiding the
                // .scan-region-highlight-svg, setting a border, outline, background, etc.
                this.$overlay.innerHTML = '<svg class="scan-region-highlight-svg" viewBox="0 0 238 238" '
                    + 'preserveAspectRatio="none" style="position:absolute;width:100%;height:100%;left:0;top:0;'
                    + 'fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round">'
                    + '<path d="M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 '
                    + '0H10a8 8 0 0 1-8-8v-21"/></svg>';
                try {
                    this.$overlay.firstElementChild.animate({ transform: ['scale(.98)', 'scale(1.01)'] }, {
                        duration: 400,
                        iterations: Infinity,
                        direction: 'alternate',
                        easing: 'ease-in-out',
                    });
                }
                catch (e) { }
                videoContainer.insertBefore(this.$overlay, this.$video.nextSibling);
            }
            if (options.highlightCodeOutline) {
                // default style; can be overwritten via css
                this.$overlay.insertAdjacentHTML('beforeend', '<svg class="code-outline-highlight" preserveAspectRatio="none" style="display:none;width:100%;'
                    + 'height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;'
                    + 'stroke-linecap:round;stroke-linejoin:round"><polygon/></svg>');
                this.$codeOutlineHighlight = this.$overlay.lastElementChild;
            }
        }
        this._scanRegion = this._calculateScanRegion(video);
        requestAnimationFrame(() => {
            // Checking in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle.
            const videoStyle = window.getComputedStyle(video);
            if (videoStyle.display === 'none') {
                video.style.setProperty('display', 'block', 'important');
                shouldHideVideo = true;
            }
            if (videoStyle.visibility !== 'visible') {
                video.style.setProperty('visibility', 'visible', 'important');
                shouldHideVideo = true;
            }
            if (shouldHideVideo) {
                // Hide the video in a way that doesn't cause Safari to stop the playback.
                console.warn('QrScanner has overwritten the video hiding style to avoid Safari stopping the playback.');
                video.style.opacity = '0';
                video.style.width = '0';
                video.style.height = '0';
                if (this.$overlay && this.$overlay.parentElement) {
                    this.$overlay.parentElement.removeChild(this.$overlay);
                }
                // @ts-ignore
                delete this.$overlay;
                // @ts-ignore
                delete this.$codeOutlineHighlight;
            }
            if (this.$overlay) {
                this._updateOverlay();
            }
        });
        video.addEventListener('play', this._onPlay);
        video.addEventListener('loadedmetadata', this._onLoadedMetaData);
        document.addEventListener('visibilitychange', this._onVisibilityChange);
        window.addEventListener('resize', this._updateOverlay);
        this._qrEnginePromise = QrScanner.createQrEngine();
    }
    async hasFlash() {
        let stream;
        try {
            if (this.$video.srcObject) {
                if (!(this.$video.srcObject instanceof MediaStream))
                    return false; // srcObject is not a camera stream
                stream = this.$video.srcObject;
            }
            else {
                stream = (await this._getCameraStream()).stream;
            }
            return 'torch' in stream.getVideoTracks()[0].getSettings();
        }
        catch (e) {
            return false;
        }
        finally {
            // close the stream we just opened for detecting whether it supports flash
            if (stream && stream !== this.$video.srcObject) {
                console.warn('Call hasFlash after successfully starting the scanner to avoid creating '
                    + 'a temporary video stream');
                QrScanner._stopVideoStream(stream);
            }
        }
    }
    isFlashOn() {
        return this._flashOn;
    }
    async toggleFlash() {
        if (this._flashOn) {
            await this.turnFlashOff();
        }
        else {
            await this.turnFlashOn();
        }
    }
    async turnFlashOn() {
        if (this._flashOn || this._destroyed)
            return;
        this._flashOn = true;
        if (!this._active || this._paused)
            return; // flash will be turned on later on .start()
        try {
            if (!await this.hasFlash())
                throw 'No flash available';
            // Note that the video track is guaranteed to exist and to be a MediaStream due to the check in hasFlash
            await this.$video.srcObject.getVideoTracks()[0].applyConstraints({
                // @ts-ignore: constraint 'torch' is unknown to ts
                advanced: [{ torch: true }],
            });
        }
        catch (e) {
            this._flashOn = false;
            throw e;
        }
    }
    async turnFlashOff() {
        if (!this._flashOn)
            return;
        // applyConstraints with torch: false does not work to turn the flashlight off, as a stream's torch stays
        // continuously on, see https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints#torch. Therefore,
        // we have to stop the stream to turn the flashlight off.
        this._flashOn = false;
        await this._restartVideoStream();
    }
    destroy() {
        this.$video.removeEventListener('loadedmetadata', this._onLoadedMetaData);
        this.$video.removeEventListener('play', this._onPlay);
        document.removeEventListener('visibilitychange', this._onVisibilityChange);
        window.removeEventListener('resize', this._updateOverlay);
        this._destroyed = true;
        this._flashOn = false;
        this.stop(); // sets this._paused = true and this._active = false
        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');
    }
    async start() {
        if (this._destroyed)
            throw new Error('The QR scanner can not be started as it had been destroyed.');
        if (this._active && !this._paused)
            return;
        if (window.location.protocol !== 'https:') {
            // warn but try starting the camera anyways
            console.warn('The camera stream is only accessible if the page is transferred via https.');
        }
        this._active = true;
        if (document.hidden)
            return; // camera will be started as soon as tab is in foreground
        this._paused = false;
        if (this.$video.srcObject) {
            // camera stream already/still set
            await this.$video.play();
            return;
        }
        try {
            const { stream, facingMode } = await this._getCameraStream();
            if (!this._active || this._paused) {
                // was stopped in the meantime
                QrScanner._stopVideoStream(stream);
                return;
            }
            this._setVideoMirror(facingMode);
            this.$video.srcObject = stream;
            await this.$video.play();
            // Restart the flash if it was previously on
            if (this._flashOn) {
                this._flashOn = false; // force turnFlashOn to restart the flash
                this.turnFlashOn().catch(() => { });
            }
        }
        catch (e) {
            if (this._paused)
                return;
            this._active = false;
            throw e;
        }
    }
    stop() {
        this.pause();
        this._active = false;
    }
    async pause(stopStreamImmediately = false) {
        this._paused = true;
        if (!this._active)
            return true;
        this.$video.pause();
        if (this.$overlay) {
            this.$overlay.style.display = 'none';
        }
        const stopStream = () => {
            if (this.$video.srcObject instanceof MediaStream) {
                // revoke srcObject only if it's a stream which was likely set by us
                QrScanner._stopVideoStream(this.$video.srcObject);
                this.$video.srcObject = null;
            }
        };
        if (stopStreamImmediately) {
            stopStream();
            return true;
        }
        await new Promise((resolve) => setTimeout(resolve, 300));
        if (!this._paused)
            return false;
        stopStream();
        return true;
    }
    async setCamera(facingModeOrDeviceId) {
        if (facingModeOrDeviceId === this._preferredCamera)
            return;
        this._preferredCamera = facingModeOrDeviceId;
        // Restart the scanner with the new camera which will also update the video mirror and the scan region.
        await this._restartVideoStream();
    }
    static async scanImage(imageOrFileOrBlobOrUrl, scanRegionOrOptions, qrEngine, canvas, disallowCanvasResizing = false, alsoTryWithoutScanRegion = false) {
        let scanRegion;
        let returnDetailedScanResult = false;
        if (scanRegionOrOptions && ('scanRegion' in scanRegionOrOptions
            || 'qrEngine' in scanRegionOrOptions
            || 'canvas' in scanRegionOrOptions
            || 'disallowCanvasResizing' in scanRegionOrOptions
            || 'alsoTryWithoutScanRegion' in scanRegionOrOptions
            || 'returnDetailedScanResult' in scanRegionOrOptions)) {
            // we got an options object using the new api
            scanRegion = scanRegionOrOptions.scanRegion;
            qrEngine = scanRegionOrOptions.qrEngine;
            canvas = scanRegionOrOptions.canvas;
            disallowCanvasResizing = scanRegionOrOptions.disallowCanvasResizing || false;
            alsoTryWithoutScanRegion = scanRegionOrOptions.alsoTryWithoutScanRegion || false;
            returnDetailedScanResult = true;
        }
        else if (scanRegionOrOptions || qrEngine || canvas || disallowCanvasResizing || alsoTryWithoutScanRegion) {
            console.warn('You\'re using a deprecated api for scanImage which will be removed in the future.');
        }
        else {
            // Only imageOrFileOrBlobOrUrl was specified and we can't distinguish between new or old api usage. For
            // backwards compatibility we have to assume the old api for now. The options object is marked as non-
            // optional in the parameter list above to make clear that ScanResult instead of string is only returned if
            // an options object was provided. However, in the future once legacy support is removed, the options object
            // should become optional.
            console.warn('Note that the return type of scanImage will change in the future. To already switch to the '
                + 'new api today, you can pass returnDetailedScanResult: true.');
        }
        const gotExternalEngine = !!qrEngine;
        try {
            let image;
            let canvasContext;
            [qrEngine, image] = await Promise.all([
                qrEngine || QrScanner.createQrEngine(),
                QrScanner._loadImage(imageOrFileOrBlobOrUrl),
            ]);
            [canvas, canvasContext] = QrScanner._drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing);
            let detailedScanResult;
            if (qrEngine instanceof Worker) {
                const qrEngineWorker = qrEngine; // for ts to know that it's still a worker later in the event listeners
                if (!gotExternalEngine) {
                    // Enable scanning of inverted color qr codes.
                    QrScanner._postWorkerMessageSync(qrEngineWorker, 'inversionMode', 'both');
                }
                detailedScanResult = await new Promise((resolve, reject) => {
                    let timeout;
                    let onMessage;
                    let onError;
                    let expectedResponseId = -1;
                    onMessage = (event) => {
                        if (event.data.id !== expectedResponseId) {
                            return;
                        }
                        qrEngineWorker.removeEventListener('message', onMessage);
                        qrEngineWorker.removeEventListener('error', onError);
                        clearTimeout(timeout);
                        if (event.data.data !== null) {
                            resolve({
                                data: event.data.data,
                                cornerPoints: QrScanner._convertPoints(event.data.cornerPoints, scanRegion),
                            });
                        }
                        else {
                            reject(QrScanner.NO_QR_CODE_FOUND);
                        }
                    };
                    onError = (error) => {
                        qrEngineWorker.removeEventListener('message', onMessage);
                        qrEngineWorker.removeEventListener('error', onError);
                        clearTimeout(timeout);
                        const errorMessage = !error ? 'Unknown Error' : (error.message || error);
                        reject('Scanner error: ' + errorMessage);
                    };
                    qrEngineWorker.addEventListener('message', onMessage);
                    qrEngineWorker.addEventListener('error', onError);
                    timeout = setTimeout(() => onError('timeout'), 10000);
                    const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);
                    expectedResponseId = QrScanner._postWorkerMessageSync(qrEngineWorker, 'decode', imageData, [imageData.data.buffer]);
                });
            }
            else {
                detailedScanResult = await Promise.race([
                    new Promise((resolve, reject) => window.setTimeout(() => reject('Scanner error: timeout'), 10000)),
                    (async () => {
                        try {
                            const [scanResult] = await qrEngine.detect(canvas);
                            if (!scanResult)
                                throw QrScanner.NO_QR_CODE_FOUND;
                            return {
                                data: scanResult.rawValue,
                                cornerPoints: QrScanner._convertPoints(scanResult.cornerPoints, scanRegion),
                            };
                        }
                        catch (e) {
                            const errorMessage = e.message || e;
                            if (/not implemented|service unavailable/.test(errorMessage)) {
                                // Not implemented can apparently for some reason happen even though getSupportedFormats
                                // in createQrScanner reported that it's supported, see issue #98.
                                // Service unavailable can happen after some time when the BarcodeDetector crashed and
                                // can theoretically be recovered from by creating a new BarcodeDetector. However, in
                                // newer browsers this issue does not seem to be present anymore and therefore we do not
                                // apply this optimization anymore but just set _disableBarcodeDetector in both cases.
                                // Also note that if we got an external qrEngine that crashed, we should possibly notify
                                // the caller about it, but we also don't do this here, as it's such an unlikely case.
                                QrScanner._disableBarcodeDetector = true;
                                // retry without passing the broken BarcodeScanner instance
                                return QrScanner.scanImage(imageOrFileOrBlobOrUrl, {
                                    scanRegion,
                                    canvas,
                                    disallowCanvasResizing,
                                    alsoTryWithoutScanRegion,
                                });
                            }
                            throw `Scanner error: ${errorMessage}`;
                        }
                    })(),
                ]);
            }
            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;
        }
        catch (e) {
            if (!scanRegion || !alsoTryWithoutScanRegion)
                throw e;
            const detailedScanResult = await QrScanner.scanImage(imageOrFileOrBlobOrUrl, { qrEngine, canvas, disallowCanvasResizing });
            return returnDetailedScanResult ? detailedScanResult : detailedScanResult.data;
        }
        finally {
            if (!gotExternalEngine) {
                QrScanner._postWorkerMessage(qrEngine, 'close');
            }
        }
    }
    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {
        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native
        // implementations work also well with colored qr codes.
        QrScanner._postWorkerMessage(this._qrEnginePromise, 'grayscaleWeights', { red, green, blue, useIntegerApproximation });
    }
    setInversionMode(inversionMode) {
        // Note that for the native BarcodeDecoder or if the worker was destroyed, this is a no-op. However, the native
        // implementations scan normal and inverted qr codes by default
        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);
    }
    static async createQrEngine(workerPath) {
        if (workerPath) {
            console.warn('Specifying a worker path is not required and not supported anymore.');
        }
        await initDecoder();
        // @ts-ignore no types defined for import
        const createWorker = () => import('./qr-scanner-worker.min.js')
            .then((module) => module.createWorker());
        const useBarcodeDetector = !QrScanner._disableBarcodeDetector
            && 'BarcodeDetector' in window
            && BarcodeDetector.getSupportedFormats
            && (await BarcodeDetector.getSupportedFormats()).includes('qr_code');
        if (!useBarcodeDetector)
            return createWorker();
        // On Macs with an M1/M2 processor and macOS Ventura (macOS version 13), the BarcodeDetector is broken in
        // Chromium based browsers, regardless of the version. For that constellation, the BarcodeDetector does not
        // error but does not detect QR codes. Macs without an M1/M2 or before Ventura are fine.
        // See issue #209 and https://bugs.chromium.org/p/chromium/issues/detail?id=1382442
        // TODO update this once the issue in macOS is fixed
        const userAgentData = navigator.userAgentData;
        const isChromiumOnMacWithArmVentura = userAgentData // all Chromium browsers support userAgentData
            && userAgentData.brands.some(({ brand }) => /Chromium/i.test(brand))
            && /mac ?OS/i.test(userAgentData.platform)
            // Does it have an ARM chip (e.g. M1/M2) and Ventura? Check this last as getHighEntropyValues can
            // theoretically trigger a browser prompt, although no browser currently does seem to show one.
            // If browser or user refused to return the requested values, assume broken ARM Ventura, to be safe.
            && await userAgentData.getHighEntropyValues(['architecture', 'platformVersion'])
                .then(({ architecture, platformVersion }) => /arm/i.test(architecture || 'arm') && parseInt(platformVersion || '13') >= /* Ventura */ 13)
                .catch(() => true);
        if (isChromiumOnMacWithArmVentura)
            return createWorker();
        return new BarcodeDetector({ formats: ['qr_code'] });
    }
    _onPlay() {
        this._scanRegion = this._calculateScanRegion(this.$video);
        this._updateOverlay();
        if (this.$overlay) {
            this.$overlay.style.display = '';
        }
        this._scanFrame();
    }
    _onLoadedMetaData() {
        this._scanRegion = this._calculateScanRegion(this.$video);
        this._updateOverlay();
    }
    _onVisibilityChange() {
        if (document.hidden) {
            this.pause();
        }
        else if (this._active) {
            this.start();
        }
    }
    _calculateScanRegion(video) {
        // Default scan region calculation. Note that this can be overwritten in the constructor.
        const smallestDimension = Math.min(video.videoWidth, video.videoHeight);
        const scanRegionSize = Math.round(2 / 3 * smallestDimension);
        return {
            x: Math.round((video.videoWidth - scanRegionSize) / 2),
            y: Math.round((video.videoHeight - scanRegionSize) / 2),
            width: scanRegionSize,
            height: scanRegionSize,
            downScaledWidth: this._legacyCanvasSize,
            downScaledHeight: this._legacyCanvasSize,
        };
    }
    _updateOverlay() {
        requestAnimationFrame(() => {
            // Running in requestAnimationFrame which should avoid a potential additional re-flow for getComputedStyle
            // and offsetWidth, offsetHeight, offsetLeft, offsetTop.
            if (!this.$overlay)
                return;
            const video = this.$video;
            const videoWidth = video.videoWidth;
            const videoHeight = video.videoHeight;
            const elementWidth = video.offsetWidth;
            const elementHeight = video.offsetHeight;
            const elementX = video.offsetLeft;
            const elementY = video.offsetTop;
            const videoStyle = window.getComputedStyle(video);
            const videoObjectFit = videoStyle.objectFit;
            const videoAspectRatio = videoWidth / videoHeight;
            const elementAspectRatio = elementWidth / elementHeight;
            let videoScaledWidth;
            let videoScaledHeight;
            switch (videoObjectFit) {
                case 'none':
                    videoScaledWidth = videoWidth;
                    videoScaledHeight = videoHeight;
                    break;
                case 'fill':
                    videoScaledWidth = elementWidth;
                    videoScaledHeight = elementHeight;
                    break;
                default: // 'cover', 'contains', 'scale-down'
                    if (videoObjectFit === 'cover'
                        ? videoAspectRatio > elementAspectRatio
                        : videoAspectRatio < elementAspectRatio) {
                        // The scaled height is the element height
                        // - for 'cover' if the video aspect ratio is wider than the element aspect ratio
                        //   (scaled height matches element height and scaled width overflows element width)
                        // - for 'contains'/'scale-down' if element aspect ratio is wider than the video aspect ratio
                        //   (scaled height matched element height and element width overflows scaled width)
                        videoScaledHeight = elementHeight;
                        videoScaledWidth = videoScaledHeight * videoAspectRatio;
                    }
                    else {
                        videoScaledWidth = elementWidth;
                        videoScaledHeight = videoScaledWidth / videoAspectRatio;
                    }
                    if (videoObjectFit === 'scale-down') {
                        // for 'scale-down' the dimensions are the minimum of 'contains' and 'none'
                        videoScaledWidth = Math.min(videoScaledWidth, videoWidth);
                        videoScaledHeight = Math.min(videoScaledHeight, videoHeight);
                    }
            }
            // getComputedStyle is so nice to convert keywords (left, center, right, top, bottom) to percent and makes
            // sure to set the default of 50% if only one or no component was provided, therefore we can be sure that
            // both components are set. Additionally, it converts units other than px (e.g. rem) to px.
            const [videoX, videoY] = videoStyle.objectPosition.split(' ').map((length, i) => {
                const lengthValue = parseFloat(length);
                return length.endsWith('%')
                    ? (!i ? elementWidth - videoScaledWidth : elementHeight - videoScaledHeight) * lengthValue / 100
                    : lengthValue;
            });
            const regionWidth = this._scanRegion.width || videoWidth;
            const regionHeight = this._scanRegion.height || videoHeight;
            const regionX = this._scanRegion.x || 0;
            const regionY = this._scanRegion.y || 0;
            const overlayStyle = this.$overlay.style;
            overlayStyle.width = `${regionWidth / videoWidth * videoScaledWidth}px`;
            overlayStyle.height = `${regionHeight / videoHeight * videoScaledHeight}px`;
            overlayStyle.top = `${elementY + videoY + regionY / videoHeight * videoScaledHeight}px`;
            const isVideoMirrored = /scaleX\(-1\)/.test(video.style.transform);
            overlayStyle.left = `${elementX
                + (isVideoMirrored ? elementWidth - videoX - videoScaledWidth : videoX)
                + (isVideoMirrored ? videoWidth - regionX - regionWidth : regionX) / videoWidth * videoScaledWidth}px`;
            // apply same mirror as on video
            overlayStyle.transform = video.style.transform;
        });
    }
    static _convertPoints(points, scanRegion) {
        if (!scanRegion)
            return points;
        const offsetX = scanRegion.x || 0;
        const offsetY = scanRegion.y || 0;
        const scaleFactorX = scanRegion.width && scanRegion.downScaledWidth
            ? scanRegion.width / scanRegion.downScaledWidth
            : 1;
        const scaleFactorY = scanRegion.height && scanRegion.downScaledHeight
            ? scanRegion.height / scanRegion.downScaledHeight
            : 1;
        for (const point of points) {
            point.x = point.x * scaleFactorX + offsetX;
            point.y = point.y * scaleFactorY + offsetY;
        }
        return points;
    }
    _scanFrame() {
        if (!this._active || this.$video.paused || this.$video.ended)
            return;
        // If requestVideoFrameCallback is available use that to avoid unnecessary scans on the same frame as the
        // camera's framerate can be lower than the screen refresh rate and this._maxScansPerSecond, especially in dark
        // settings where the exposure time is longer. Both, requestVideoFrameCallback and requestAnimationFrame are not
        // being fired if the tab is in the background, which is what we want.
        const requestFrame = 'requestVideoFrameCallback' in this.$video
            // @ts-ignore
            ? this.$video.requestVideoFrameCallback.bind(this.$video)
            : requestAnimationFrame;
        requestFrame(async () => {
            if (this.$video.readyState <= 1) {
                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState
                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.
                // This also avoids false positives for videos paused after a successful scan which remains visible on
                // the canvas until the video is started again and ready.
                this._scanFrame();
                return;
            }
            const timeSinceLastScan = Date.now() - this._lastScanTimestamp;
            const minimumTimeBetweenScans = 1000 / this._maxScansPerSecond;
            if (timeSinceLastScan < minimumTimeBetweenScans) {
                await new Promise((resolve) => setTimeout(resolve, minimumTimeBetweenScans - timeSinceLastScan));
            }
            // console.log('Scan rate:', Math.round(1000 / (Date.now() - this._lastScanTimestamp)));
            this._lastScanTimestamp = Date.now();
            let result;
            try {
                result = await QrScanner.scanImage(this.$video, {
                    scanRegion: this._scanRegion,
                    qrEngine: this._qrEnginePromise,
                    canvas: this.$canvas,
                });
            }
            catch (error) {
                if (!this._active)
                    return;
                this._onDecodeError(error);
            }
            if (QrScanner._disableBarcodeDetector && !(await this._qrEnginePromise instanceof Worker)) {
                // replace the disabled BarcodeDetector
                this._qrEnginePromise = QrScanner.createQrEngine();
            }
            if (result) {
                if (this._onDecode) {
                    this._onDecode(result);
                }
                else if (this._legacyOnDecode) {
                    this._legacyOnDecode(result.data);
                }
                if (this.$codeOutlineHighlight) {
                    clearTimeout(this._codeOutlineHighlightRemovalTimeout);
                    this._codeOutlineHighlightRemovalTimeout = undefined;
                    this.$codeOutlineHighlight.setAttribute('viewBox', `${this._scanRegion.x || 0} `
                        + `${this._scanRegion.y || 0} `
                        + `${this._scanRegion.width || this.$video.videoWidth} `
                        + `${this._scanRegion.height || this.$video.videoHeight}`);
                    const polygon = this.$codeOutlineHighlight.firstElementChild;
                    polygon.setAttribute('points', result.cornerPoints.map(({ x, y }) => `${x},${y}`).join(' '));
                    this.$codeOutlineHighlight.style.display = '';
                }
            }
            else if (this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout) {
                // hide after timeout to make it flash less when on some frames the QR code is detected and on some not
                this._codeOutlineHighlightRemovalTimeout = setTimeout(() => this.$codeOutlineHighlight.style.display = 'none', 100);
            }
            this._scanFrame();
        });
    }
    _onDecodeError(error) {
        // default error handler; can be overwritten in the constructor
        if (error === QrScanner.NO_QR_CODE_FOUND)
            return;
        console.log(error);
    }
    async _getCameraStream() {
        if (!navigator.mediaDevices)
            throw 'Camera not found.';
        const preferenceType = /^(environment|user)$/.test(this._preferredCamera)
            ? 'facingMode'
            : 'deviceId';
        const constraintsWithoutCamera = [{
                width: { min: 1024 }
            }, {
                width: { min: 768 }
            }, {}];
        const constraintsWithCamera = constraintsWithoutCamera.map((constraint) => Object.assign({}, constraint, {
            [preferenceType]: { exact: this._preferredCamera },
        }));
        for (const constraints of [...constraintsWithCamera, ...constraintsWithoutCamera]) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: constraints, audio: false });
                // Try to determine the facing mode from the stream, otherwise use a guess or 'environment' as
                // default. Note that the guess is not always accurate as Safari returns cameras of different facing
                // mode, even for exact facingMode constraints.
                const facingMode = this._getFacingMode(stream)
                    || (constraints.facingMode
                        ? this._preferredCamera // a facing mode we were able to fulfill
                        : (this._preferredCamera === 'environment'
                            ? 'user' // switch as _preferredCamera was environment but we are not able to fulfill it
                            : 'environment' // switch from unfulfilled user facingMode or default to environment
                        ));
                return { stream, facingMode };
            }
            catch (e) { }
        }
        throw 'Camera not found.';
    }
    async _restartVideoStream() {
        // Note that we always pause the stream and not only if !this._paused as even if this._paused === true, the
        // stream might still be running, as it's by default only stopped after a delay of 300ms.
        const wasPaused = this._paused;
        const paused = await this.pause(true);
        if (!paused || wasPaused || !this._active)
            return;
        await this.start();
    }
    static _stopVideoStream(stream) {
        for (const track of stream.getTracks()) {
            track.stop(); //  note that this will also automatically turn the flashlight off
            stream.removeTrack(track);
        }
    }
    _setVideoMirror(facingMode) {
        // in user facing mode mirror the video to make it easier for the user to position the QR code
        const scaleFactor = facingMode === 'user' ? -1 : 1;
        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';
    }
    _getFacingMode(videoStream) {
        const videoTrack = videoStream.getVideoTracks()[0];
        if (!videoTrack)
            return null; // unknown
        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13
        return /rear|back|environment/i.test(videoTrack.label)
            ? 'environment'
            : /front|user|face/i.test(videoTrack.label)
                ? 'user'
                : null; // unknown
    }
    static _drawToCanvas(image, scanRegion, canvas, disallowCanvasResizing = false) {
        canvas = canvas || document.createElement('canvas');
        const scanRegionX = scanRegion && scanRegion.x ? scanRegion.x : 0;
        const scanRegionY = scanRegion && scanRegion.y ? scanRegion.y : 0;
        const scanRegionWidth = scanRegion && scanRegion.width
            ? scanRegion.width
            : image.videoWidth || image.width;
        const scanRegionHeight = scanRegion && scanRegion.height
            ? scanRegion.height
            : image.videoHeight || image.height;
        if (!disallowCanvasResizing) {
            const canvasWidth = scanRegion && scanRegion.downScaledWidth
                ? scanRegion.downScaledWidth
                : scanRegionWidth;
            const canvasHeight = scanRegion && scanRegion.downScaledHeight
                ? scanRegion.downScaledHeight
                : scanRegionHeight;
            // Setting the canvas width or height clears the canvas, even if the values didn't change, therefore only
            // set them if they actually changed.
            if (canvas.width !== canvasWidth) {
                canvas.width = canvasWidth;
            }
            if (canvas.height !== canvasHeight) {
                canvas.height = canvasHeight;
            }
        }
        const context = canvas.getContext('2d', { alpha: false });
        context.imageSmoothingEnabled = false; // gives less blurry images
        context.drawImage(image, scanRegionX, scanRegionY, scanRegionWidth, scanRegionHeight, 0, 0, canvas.width, canvas.height);
        return [canvas, context];
    }
    static async _loadImage(imageOrFileOrBlobOrUrl) {
        if (imageOrFileOrBlobOrUrl instanceof Image) {
            await QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl);
            return imageOrFileOrBlobOrUrl;
        }
        else if (imageOrFileOrBlobOrUrl instanceof HTMLVideoElement
            || imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement
            || imageOrFileOrBlobOrUrl instanceof SVGImageElement
            || 'OffscreenCanvas' in window && imageOrFileOrBlobOrUrl instanceof OffscreenCanvas
            || 'ImageBitmap' in window && imageOrFileOrBlobOrUrl instanceof ImageBitmap) {
            return imageOrFileOrBlobOrUrl;
        }
        else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob
            || imageOrFileOrBlobOrUrl instanceof URL || typeof imageOrFileOrBlobOrUrl === 'string') {
            const image = new Image();
            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {
                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);
            }
            else {
                image.src = imageOrFileOrBlobOrUrl.toString();
            }
            try {
                await QrScanner._awaitImageLoad(image);
                return image;
            }
            finally {
                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {
                    URL.revokeObjectURL(image.src);
                }
            }
        }
        else {
            throw 'Unsupported image type.';
        }
    }
    static async _awaitImageLoad(image) {
        if (image.complete && image.naturalWidth !== 0)
            return; // already loaded
        await new Promise((resolve, reject) => {
            const listener = (event) => {
                image.removeEventListener('load', listener);
                image.removeEventListener('error', listener);
                if (event instanceof ErrorEvent) {
                    reject('Image load error');
                }
                else {
                    resolve();
                }
            };
            image.addEventListener('load', listener);
            image.addEventListener('error', listener);
        });
    }
    static async _postWorkerMessage(qrEngineOrQrEnginePromise, type, data, transfer) {
        return QrScanner._postWorkerMessageSync(await qrEngineOrQrEnginePromise, type, data, transfer);
    }
    // sync version of _postWorkerMessage without performance overhead of async functions
    static _postWorkerMessageSync(qrEngine, type, data, transfer) {
        if (!(qrEngine instanceof Worker))
            return -1;
        const id = QrScanner._workerMessageId++;
        qrEngine.postMessage({
            id,
            type,
            data,
        }, transfer);
        return id;
    }
}
QrScanner.DEFAULT_CANVAS_SIZE = 400;
QrScanner.NO_QR_CODE_FOUND = 'No QR code found';
QrScanner._disableBarcodeDetector = true;
QrScanner._workerMessageId = 0;

export { QrScanner as default };
//# sourceMappingURL=qr-scanner.min.js.map
